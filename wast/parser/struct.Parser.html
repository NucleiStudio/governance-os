<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="An in-progress parser for the tokens of a WebAssembly text file."><meta name="keywords" content="rust, rustlang, rust-lang, Parser"><title>Parser in wast::parser - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings"></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc struct"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../wast/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><p class="location">Struct Parser</p><div class="sidebar-elems"><div class="block items"><a class="sidebar-title" href="#implementations">Methods</a><div class="sidebar-links"><a href="#method.cur_span">cur_span</a><a href="#method.error">error</a><a href="#method.is_empty">is_empty</a><a href="#method.lookahead1">lookahead1</a><a href="#method.parens">parens</a><a href="#method.parens_depth">parens_depth</a><a href="#method.parse">parse</a><a href="#method.peek">peek</a><a href="#method.peek2">peek2</a><a href="#method.prev_span">prev_span</a><a href="#method.register_annotation">register_annotation</a><a href="#method.step">step</a></div><a class="sidebar-title" href="#trait-implementations">Trait Implementations</a><div class="sidebar-links"><a href="#impl-Clone">Clone</a><a href="#impl-Copy">Copy</a></div><a class="sidebar-title" href="#synthetic-implementations">Auto Trait Implementations</a><div class="sidebar-links"><a href="#impl-RefUnwindSafe">!RefUnwindSafe</a><a href="#impl-Send">!Send</a><a href="#impl-Sync">!Sync</a><a href="#impl-Unpin">Unpin</a><a href="#impl-UnwindSafe">!UnwindSafe</a></div><a class="sidebar-title" href="#blanket-implementations">Blanket Implementations</a><div class="sidebar-links"><a href="#impl-Any">Any</a><a href="#impl-Borrow%3CT%3E">Borrow&lt;T&gt;</a><a href="#impl-BorrowMut%3CT%3E">BorrowMut&lt;T&gt;</a><a href="#impl-From%3CT%3E">From&lt;T&gt;</a><a href="#impl-Into%3CU%3E">Into&lt;U&gt;</a><a href="#impl-ToOwned">ToOwned</a><a href="#impl-TryFrom%3CU%3E">TryFrom&lt;U&gt;</a><a href="#impl-TryInto%3CU%3E">TryInto&lt;U&gt;</a></div></div><p class="location"><a href="../index.html">wast</a>::<wbr><a href="index.html">parser</a></p><div id="sidebar-vars" data-name="Parser" data-ty="struct" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu"><img src="../../brush.svg" width="18" height="18" alt="Pick another theme!"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" class="help-button">?</button>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" height="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Struct <a href="../index.html">wast</a>::<wbr><a href="index.html">parser</a>::<wbr><a class="struct" href="">Parser</a><button id="copy-path" onclick="copy_path(this)">⎘</button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/wast/parser.rs.html#308-310" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><pre class="rust struct">pub struct Parser&lt;'a&gt; { /* fields omitted */ }</pre></div><div class="docblock"><p>An in-progress parser for the tokens of a WebAssembly text file.</p>
<p>A <code>Parser</code> is argument to the <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> trait and is now the input stream is
interacted with to parse new items. Cloning <a href="struct.Parser.html" title="Parser"><code>Parser</code></a> or copying a parser
refers to the same stream of tokens to parse, you cannot clone a <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>
and clone two items.</p>
<p>For more information about a <a href="struct.Parser.html" title="Parser"><code>Parser</code></a> see its methods.</p>
</div><h2 id="implementations" class="small-section-header">Implementations<a href="#implementations" class="anchor"></a></h2><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#415-887" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.is_empty" class="method"><code>pub fn <a href="#method.is_empty" class="fnname">is_empty</a>(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a href="#method.is_empty" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#425-430" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns whether there are no more <code>Token</code> tokens to parse from this
<a href="struct.Parser.html" title="Parser"><code>Parser</code></a>.</p>
<p>This indicates that either we’ve reached the end of the input, or we’re
a sub-<a href="struct.Parser.html" title="Parser"><code>Parser</code></a> inside of a parenthesized expression and we’ve hit the
<code>)</code> token.</p>
<p>Note that if <code>false</code> is returned there <em>may</em> be more comments. Comments
and whitespace are not considered for whether this parser is empty.</p>
</div><h4 id="method.parse" class="method"><code>pub fn <a href="#method.parse" class="fnname">parse</a>&lt;T:&nbsp;<a class="trait" href="trait.Parse.html" title="trait wast::parser::Parse">Parse</a>&lt;'a&gt;&gt;(self) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</code><a href="#method.parse" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#489-491" title="goto source code">[src]</a></h4><div class="docblock"><p>Parses a <code>T</code> from this <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>.</p>
<p>This method has a trivial definition (it simply calls
<a href="trait.Parse.html#tymethod.parse"><code>T::parse</code></a>) but is here for syntactic purposes. This is
what you’ll call 99% of the time in a <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> implementation in order
to parse sub-items.</p>
<p>Typically you always want to use <code>?</code> with the result of this method, you
should not handle errors and decide what else to parse. To handle
branches in parsing, use <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>A good example of using <code>parse</code> is to see how the <a href="../struct.TableType.html"><code>TableType</code></a> type is
parsed in this crate. A <a href="../struct.TableType.html"><code>TableType</code></a> is defined in the official
specification as <a href="https://webassembly.github.io/spec/core/text/types.html#table-types"><code>tabletype</code></a> and is defined as:</p>
<pre><code class="language-text">tabletype ::= lim:limits et:reftype
</code></pre>
<p>so to parse a <a href="../struct.TableType.html"><code>TableType</code></a> we recursively need to parse a <a href="../struct.Limits.html"><code>Limits</code></a>
and a <a href="../struct.RefType.html"><code>RefType</code></a></p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">TableType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">limits</span>: <span class="ident">Limits</span>,
    <span class="ident">elem</span>: <span class="ident">RefType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">TableType</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// parse the `lim` then `et` in sequence</span>
        <span class="prelude-val">Ok</span>(<span class="ident">TableType</span> {
            <span class="ident">limits</span>: <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>,
            <span class="ident">elem</span>: <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>,
        })
    }
}</pre></div>
</div><h4 id="method.peek" class="method"><code>pub fn <a href="#method.peek" class="fnname">peek</a>&lt;T:&nbsp;<a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a href="#method.peek" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#546-548" title="goto source code">[src]</a></h4><div class="docblock"><p>Performs a cheap test to see whether the current token in this stream is
<code>T</code>.</p>
<p>This method can be used to efficiently determine what next to parse. The
<a href="trait.Peek.html" title="Peek"><code>Peek</code></a> trait is defined for types which can be used to test if they’re
the next item in the input stream.</p>
<p>Nothing is actually parsed in this method, nor does this mutate the
state of this <a href="struct.Parser.html" title="Parser"><code>Parser</code></a>. Instead, this simply performs a check.</p>
<p>This method is frequently combined with the <a href="struct.Parser.html#method.lookahead1" title="Parser::lookahead1"><code>Parser::lookahead1</code></a>
method to automatically produce nice error messages if some tokens
aren’t found.</p>
<h1 id="examples-1" class="section-header"><a href="#examples-1">Examples</a></h1>
<p>For an example of using the <code>peek</code> method let’s take a look at parsing
the <a href="../struct.Limits.html"><code>Limits</code></a> type. This is <a href="https://webassembly.github.io/spec/core/text/types.html#limits">defined in the official spec</a> as:</p>
<pre><code class="language-text">limits ::= n:u32
         | n:u32 m:u32
</code></pre>
<p>which means that it’s either one <code>u32</code> token or two, so we need to know
whether to consume two tokens or one:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Limits</span> {
    <span class="ident">min</span>: <span class="ident">u32</span>,
    <span class="ident">max</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Limits</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Always parse the first number...</span>
        <span class="kw">let</span> <span class="ident">min</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;

        <span class="comment">// ... and then test if there&#39;s a second number before parsing</span>
        <span class="kw">let</span> <span class="ident">max</span> <span class="op">=</span> <span class="kw">if</span> <span class="ident">parser</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Some</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>)
        } <span class="kw">else</span> {
            <span class="prelude-val">None</span>
        };

        <span class="prelude-val">Ok</span>(<span class="ident">Limits</span> { <span class="ident">min</span>, <span class="ident">max</span> })
    }
}</pre></div>
</div><h4 id="method.peek2" class="method"><code>pub fn <a href="#method.peek2" class="fnname">peek2</a>&lt;T:&nbsp;<a class="trait" href="trait.Peek.html" title="trait wast::parser::Peek">Peek</a>&gt;(self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.bool.html">bool</a></code><a href="#method.peek2" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#552-559" title="goto source code">[src]</a></h4><div class="docblock"><p>Same as the <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a> method, except checks the next token, not
the current token.</p>
</div><h4 id="method.lookahead1" class="method"><code>pub fn <a href="#method.lookahead1" class="fnname">lookahead1</a>(self) -&gt; <a class="struct" href="struct.Lookahead1.html" title="struct wast::parser::Lookahead1">Lookahead1</a>&lt;'a&gt;</code><a href="#method.lookahead1" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#610-615" title="goto source code">[src]</a></h4><div class="docblock"><p>A helper structure to perform a sequence of <code>peek</code> operations and if
they all fail produce a nice error message.</p>
<p>This method purely exists for conveniently producing error messages and
provides no functionality that <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a> doesn’t already give.
The <a href="struct.Lookahead1.html" title="Lookahead1"><code>Lookahead1</code></a> structure has one main method <a href="struct.Lookahead1.html#method.peek" title="Lookahead1::peek"><code>Lookahead1::peek</code></a>,
which is the same method as <a href="struct.Parser.html#method.peek" title="Parser::peek"><code>Parser::peek</code></a>. The difference is that the
<a href="struct.Lookahead1.html#method.error" title="Lookahead1::error"><code>Lookahead1::error</code></a> method needs no arguments.</p>
<h1 id="examples-2" class="section-header"><a href="#examples-2">Examples</a></h1>
<p>Let’s look at the parsing of <a href="../enum.Index.html"><code>Index</code></a>. This type is either a <code>u32</code> or
an <a href="../struct.Id.html"><code>Id</code></a> and is used in name resolution primarily. The <a href="https://webassembly.github.io/spec/core/text/modules.html#indices">official
grammar for an index</a> is:</p>
<pre><code class="language-text">idx ::= x:u32
      | v:id
</code></pre>
<p>Which is to say that an index is either a <code>u32</code> or an <a href="../struct.Id.html"><code>Id</code></a>. When
parsing an <a href="../enum.Index.html"><code>Index</code></a> we can do:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">enum</span> <span class="ident">Index</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">Num</span>(<span class="ident">u32</span>),
    <span class="ident">Id</span>(<span class="ident">Id</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>),
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Index</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">l</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">lookahead1</span>();
        <span class="kw">if</span> <span class="ident">l</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">Id</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">Index::Id</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))
        } <span class="kw">else</span> <span class="kw">if</span> <span class="ident">l</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">u32</span><span class="op">&gt;</span>() {
            <span class="prelude-val">Ok</span>(<span class="ident">Index::Num</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>))
        } <span class="kw">else</span> {
            <span class="comment">// produces error message of `expected identifier or u32`</span>
            <span class="prelude-val">Err</span>(<span class="ident">l</span>.<span class="ident">error</span>())
        }
    }
}</pre></div>
</div><h4 id="method.parens" class="method"><code>pub fn <a href="#method.parens" class="fnname">parens</a>&lt;T&gt;(self, f: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt;</code><a href="#method.parens" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#660-681" title="goto source code">[src]</a></h4><div class="docblock"><p>Parse an item surrounded by parentheses.</p>
<p>WebAssembly’s text format is all based on s-expressions, so naturally
you’re going to want to parse a lot of parenthesized things! As noted in
the documentation of <a href="trait.Parse.html" title="Parse"><code>Parse</code></a> you typically don’t parse your own
surrounding <code>(</code> and <code>)</code> tokens, but the parser above you parsed them for
you. This is method method the parser above you uses.</p>
<p>This method will parse a <code>(</code> token, and then call <code>f</code> on a sub-parser
which when finished asserts that a <code>)</code> token is the next token. This
requires that <code>f</code> consumes all tokens leading up to the paired <code>)</code>.</p>
<p>Usage will often simply be <code>parser.parens(|p| p.parse())?</code> to
automatically parse a type within parentheses, but you can, as always,
go crazy and do whatever you’d like too.</p>
<h1 id="examples-3" class="section-header"><a href="#examples-3">Examples</a></h1>
<p>A good example of this is to see how a <code>Module</code> is parsed. This isn’t
the exact definition, but it’s close enough!</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// And then everything else is `(field ...)`, so while we&#39;ve got</span>
        <span class="comment">// items left we continuously parse parenthesized items.</span>
        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">while</span> <span class="op">!</span><span class="ident">parser</span>.<span class="ident">is_empty</span>() {
            <span class="ident">fields</span>.<span class="ident">push</span>(<span class="ident">parser</span>.<span class="ident">parens</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">parse</span>())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">fields</span> })
    }
}</pre></div>
</div><h4 id="method.parens_depth" class="method"><code>pub fn <a href="#method.parens_depth" class="fnname">parens_depth</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.usize.html">usize</a></code><a href="#method.parens_depth" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#687-689" title="goto source code">[src]</a></h4><div class="docblock"><p>Return the depth of nested parens we’ve parsed so far.</p>
<p>This is a low-level method that is only useful for implementing
recursion limits in custom parsers.</p>
</div><h4 id="method.step" class="method"><code>pub fn <a href="#method.step" class="fnname">step</a>&lt;F, T&gt;(self, f: F) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;T&gt; <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;F: <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/function/trait.FnOnce.html" title="trait core::ops::function::FnOnce">FnOnce</a>(<a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;) -&gt; <a class="type" href="type.Result.html" title="type wast::parser::Result">Result</a>&lt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">(</a>T, <a class="struct" href="struct.Cursor.html" title="struct wast::parser::Cursor">Cursor</a>&lt;'a&gt;<a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.tuple.html">)</a>&gt;,&nbsp;</span></code><a href="#method.step" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#704-711" title="goto source code">[src]</a></h4><div class="docblock"><p>A low-level parsing method you probably won’t use.</p>
<p>This is used to implement parsing of the most primitive types in the
<a href="crate::ast"><code>ast</code></a> module. You probably don’t want to use this, but
probably want to use something like <a href="struct.Parser.html#method.parse" title="Parser::parse"><code>Parser::parse</code></a> or
<a href="struct.Parser.html#method.parens" title="Parser::parens"><code>Parser::parens</code></a>.</p>
</div><h4 id="method.error" class="method"><code>pub fn <a href="#method.error" class="fnname">error</a>(self, msg: impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/fmt/trait.Display.html" title="trait core::fmt::Display">Display</a>) -&gt; <a class="struct" href="../struct.Error.html" title="struct wast::Error">Error</a></code><a href="#method.error" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#719-721" title="goto source code">[src]</a></h4><div class="docblock"><p>Creates an error whose line/column information is pointing at the
current token.</p>
<p>This is used to produce human-readable error messages which point to the
right location in the input stream, and the <code>msg</code> here is arbitrary text
used to associate with the error and indicate why it was generated.</p>
</div><h4 id="method.cur_span" class="method"><code>pub fn <a href="#method.cur_span" class="fnname">cur_span</a>(&amp;self) -&gt; <a class="struct" href="../struct.Span.html" title="struct wast::Span">Span</a></code><a href="#method.cur_span" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#728-730" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the span of the current token</p>
</div><h4 id="method.prev_span" class="method"><code>pub fn <a href="#method.prev_span" class="fnname">prev_span</a>(&amp;self) -&gt; <a class="struct" href="../struct.Span.html" title="struct wast::Span">Span</a></code><a href="#method.prev_span" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#733-735" title="goto source code">[src]</a></h4><div class="docblock"><p>Returns the span of the previous token</p>
</div><h4 id="method.register_annotation" class="method"><code>pub fn <a href="#method.register_annotation" class="fnname">register_annotation</a>&lt;'b&gt;(self, annotation: &amp;'b <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.str.html">str</a>) -&gt; impl <a class="trait" href="https://doc.rust-lang.org/nightly/core/ops/drop/trait.Drop.html" title="trait core::ops::drop::Drop">Drop</a> + 'b <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;'a: 'b,&nbsp;</span></code><a href="#method.register_annotation" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#865-886" title="goto source code">[src]</a></h4><div class="docblock"><p>Registers a new known annotation with this parser to allow parsing
annotations with this name.</p>
<p><a href="https://github.com/WebAssembly/annotations">WebAssembly annotations</a> are a proposal for the text format
which allows decorating the text format with custom structured
information. By default all annotations are ignored when parsing, but
the whole purpose of them is to sometimes parse them!</p>
<p>To support parsing text annotations this method is used to allow
annotations and their tokens to <em>not</em> be skipped. Once an annotation is
registered with this method, then while the return value has not been
dropped (e.g. the scope of where this function is called) annotations
with the name <code>annotation</code> will be parse of the token stream and not
implicitly skipped.</p>
<h1 id="skipping-annotations" class="section-header"><a href="#skipping-annotations">Skipping annotations</a></h1>
<p>The behavior of skipping unknown/unregistered annotations can be
somewhat subtle and surprising, so if you’re interested in parsing
annotations it’s important to point out the importance of this method
and where to call it.</p>
<p>Generally when parsing tokens you’ll be bottoming out in various
<code>Cursor</code> methods. These are all documented as advancing the stream as
much as possible to the next token, skipping “irrelevant stuff” like
comments, whitespace, etc. The <code>Cursor</code> methods will also skip unknown
annotations. This means that if you parse <em>any</em> token, it will skip over
any number of annotations that are unknown at all times.</p>
<p>To parse an annotation you must, before parsing any token of the
annotation, register the annotation via this method. This includes the
beginning <code>(</code> token, which is otherwise skipped if the annotation isn’t
marked as registered. Typically parser parse the <em>contents</em> of an
s-expression, so this means that the outer parser of an s-expression
must register the custom annotation name, rather than the inner parser.</p>
<h1 id="return" class="section-header"><a href="#return">Return</a></h1>
<p>This function returns an RAII guard which, when dropped, will unregister
the <code>annotation</code> given. Parsing <code>annotation</code> is only supported while the
returned value is still alive, and once dropped the parser will go back
to skipping annotations with the name <code>annotation</code>.</p>
<h1 id="example" class="section-header"><a href="#example">Example</a></h1>
<p>Let’s see an example of how the <code>@name</code> annotation is parsed for modules
to get an idea of how this works:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">name</span>: <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="ident">NameAnnotation</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// Next may be `(@name &quot;foo&quot;)`. Typically this annotation would</span>
        <span class="comment">// skipped, but we don&#39;t want it skipped, so we register it.</span>
        <span class="comment">// Note that the parse implementation of</span>
        <span class="comment">// `Option&lt;NameAnnotation&gt;` is the one that consumes the</span>
        <span class="comment">// parentheses here.</span>
        <span class="kw">let</span> <span class="ident">_r</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">register_annotation</span>(<span class="string">&quot;name&quot;</span>);
        <span class="kw">let</span> <span class="ident">name</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>;

        <span class="comment">// ... and normally you&#39;d otherwise parse module fields here ...</span>

        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">name</span> })
    }
}</pre></div>
<p>Another example is how we parse the <code>@custom</code> annotation. Note that this
is parsed as part of <code>ModuleField</code>, so note how the annotation is
registered <em>before</em> we parse the parentheses of the annotation.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered">
<span class="kw">struct</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">fields</span>: <span class="ident">Vec</span><span class="op">&lt;</span><span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">Module</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Modules start out with a `module` keyword</span>
        <span class="ident">parser</span>.<span class="ident">parse</span>::<span class="op">&lt;</span><span class="ident">kw::module</span><span class="op">&gt;</span>()<span class="question-mark">?</span>;

        <span class="comment">// register the `@custom` annotation *first* before we start</span>
        <span class="comment">// parsing fields, because each field is contained in</span>
        <span class="comment">// parentheses and to parse the parentheses of an annotation we</span>
        <span class="comment">// have to known to not skip it.</span>
        <span class="kw">let</span> <span class="ident">_r</span> <span class="op">=</span> <span class="ident">parser</span>.<span class="ident">register_annotation</span>(<span class="string">&quot;custom&quot;</span>);

        <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">fields</span> <span class="op">=</span> <span class="ident">Vec::new</span>();
        <span class="kw">while</span> <span class="op">!</span><span class="ident">parser</span>.<span class="ident">is_empty</span>() {
            <span class="ident">fields</span>.<span class="ident">push</span>(<span class="ident">parser</span>.<span class="ident">parens</span>(<span class="op">|</span><span class="ident">p</span><span class="op">|</span> <span class="ident">p</span>.<span class="ident">parse</span>())<span class="question-mark">?</span>);
        }
        <span class="prelude-val">Ok</span>(<span class="ident">Module</span> { <span class="ident">fields</span> })
    }
}

<span class="kw">enum</span> <span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="ident">Custom</span>(<span class="ident">Custom</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>),
    <span class="comment">// ...</span>
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="ident">Parse</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">ModuleField</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span> {
    <span class="kw">fn</span> <span class="ident">parse</span>(<span class="ident">parser</span>: <span class="ident">Parser</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
        <span class="comment">// Note that because we have previously registered the `@custom`</span>
        <span class="comment">// annotation with the parser we known that `peek` methods like</span>
        <span class="comment">// this, working on the annotation token, are enabled to ever</span>
        <span class="comment">// return `true`.</span>
        <span class="kw">if</span> <span class="ident">parser</span>.<span class="ident">peek</span>::<span class="op">&lt;</span><span class="ident">annotation::custom</span><span class="op">&gt;</span>() {
            <span class="kw">return</span> <span class="prelude-val">Ok</span>(<span class="ident">ModuleField::Custom</span>(<span class="ident">parser</span>.<span class="ident">parse</span>()<span class="question-mark">?</span>));
        }

        <span class="comment">// .. typically we&#39;d parse other module fields here...</span>

        <span class="prelude-val">Err</span>(<span class="ident">parser</span>.<span class="ident">error</span>(<span class="string">&quot;unknown module field&quot;</span>))
    }
}</pre></div>
</div></div></details><h2 id="trait-implementations" class="small-section-header">Trait Implementations<a href="#trait-implementations" class="anchor"></a></h2><div id="trait-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Clone" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-Clone" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#307" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.clone" class="method hidden trait-impl"><code>fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone" class="fnname">clone</a>(&amp;self) -&gt; <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#method.clone" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#307" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Returns a copy of the value. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#tymethod.clone">Read more</a></p>
</div><h4 id="method.clone_from" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from" class="fnname">clone_from</a>(&amp;mut self, source: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>Self)</code><span class="since" title="Stable since Rust version 1.0.0">1.0.0</span><a href="#method.clone_from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/clone.rs.html#130" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs copy-assignment from <code>source</code>. <a href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html#method.clone_from">Read more</a></p>
</div></div></details><h3 id="impl-Copy" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Copy.html" title="trait core::marker::Copy">Copy</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-Copy" class="anchor"></a><a class="srclink" href="../../src/wast/parser.rs.html#307" title="goto source code">[src]</a></h3></div><h2 id="synthetic-implementations" class="small-section-header">Auto Trait Implementations<a href="#synthetic-implementations" class="anchor"></a></h2><div id="synthetic-implementations-list"><h3 id="impl-RefUnwindSafe" class="impl"><code class="in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.RefUnwindSafe.html" title="trait std::panic::RefUnwindSafe">RefUnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-RefUnwindSafe" class="anchor"></a></h3><h3 id="impl-Send" class="impl"><code class="in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Send.html" title="trait core::marker::Send">Send</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-Send" class="anchor"></a></h3><h3 id="impl-Sync" class="impl"><code class="in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sync.html" title="trait core::marker::Sync">Sync</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-Sync" class="anchor"></a></h3><h3 id="impl-Unpin" class="impl"><code class="in-band">impl&lt;'a&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Unpin.html" title="trait core::marker::Unpin">Unpin</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-Unpin" class="anchor"></a></h3><h3 id="impl-UnwindSafe" class="impl"><code class="in-band">impl&lt;'a&gt; !<a class="trait" href="https://doc.rust-lang.org/nightly/std/panic/trait.UnwindSafe.html" title="trait std::panic::UnwindSafe">UnwindSafe</a> for <a class="struct" href="struct.Parser.html" title="struct wast::parser::Parser">Parser</a>&lt;'a&gt;</code><a href="#impl-UnwindSafe" class="anchor"></a></h3></div><h2 id="blanket-implementations" class="small-section-header">Blanket Implementations<a href="#blanket-implementations" class="anchor"></a></h2><div id="blanket-implementations-list"><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Any" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html" title="trait core::any::Any">Any</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: 'static + ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Any" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#131-135" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.type_id" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id" class="fnname">type_id</a>(&amp;self) -&gt; <a class="struct" href="https://doc.rust-lang.org/nightly/core/any/struct.TypeId.html" title="struct core::any::TypeId">TypeId</a></code><a href="#method.type_id" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/any.rs.html#132" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Gets the <code>TypeId</code> of <code>self</code>. <a href="https://doc.rust-lang.org/nightly/core/any/trait.Any.html#tymethod.type_id">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Borrow%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html" title="trait core::borrow::Borrow">Borrow</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-Borrow%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#208-213" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.borrow" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow" class="fnname">borrow</a>(&amp;self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;</a>T</code><a href="#method.borrow" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#210" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Immutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.Borrow.html#tymethod.borrow">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-BorrowMut%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html" title="trait core::borrow::BorrowMut">BorrowMut</a>&lt;T&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: ?<a class="trait" href="https://doc.rust-lang.org/nightly/core/marker/trait.Sized.html" title="trait core::marker::Sized">Sized</a>,&nbsp;</span></code><a href="#impl-BorrowMut%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#216-220" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.borrow_mut" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut" class="fnname">borrow_mut</a>(&amp;mut self) -&gt; <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T</code><a href="#method.borrow_mut" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/borrow.rs.html#217" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Mutably borrows from an owned value. <a href="https://doc.rust-lang.org/nightly/core/borrow/trait.BorrowMut.html#tymethod.borrow_mut">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-From%3CT%3E" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt; for T</code><a href="#impl-From%3CT%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#544-548" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.from" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html#tymethod.from" class="fnname">from</a>(t: T) -&gt; T</code><a href="#method.from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#545" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-Into%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.From.html" title="trait core::convert::From">From</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-Into%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#533-540" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="method.into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html#tymethod.into" class="fnname">into</a>(self) -&gt; U</code><a href="#method.into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#537" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-ToOwned" class="impl"><code class="in-band">impl&lt;T&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html" title="trait alloc::borrow::ToOwned">ToOwned</a> for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;T: <a class="trait" href="https://doc.rust-lang.org/nightly/core/clone/trait.Clone.html" title="trait core::clone::Clone">Clone</a>,&nbsp;</span></code><a href="#impl-ToOwned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#81-93" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Owned" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#associatedtype.Owned" class="type">Owned</a> = T</code><a href="#associatedtype.Owned" class="anchor"></a></h4><div class='docblock'><p>The resulting type after obtaining ownership.</p>
</div><h4 id="method.to_owned" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned" class="fnname">to_owned</a>(&amp;self) -&gt; T</code><a href="#method.to_owned" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#86" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Creates owned data from borrowed data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#tymethod.to_owned">Read more</a></p>
</div><h4 id="method.clone_into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into" class="fnname">clone_into</a>(&amp;self, target: <a class="primitive" href="https://doc.rust-lang.org/nightly/std/primitive.reference.html">&amp;mut </a>T)</code><a href="#method.clone_into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/alloc/borrow.rs.html#90" title="goto source code">[src]</a></h4><div class="item-info hidden"><div class="stab unstable"><details><summary><span class="emoji">🔬</span> This is a nightly-only experimental API. (<code>toowned_clone_into</code>)</summary><p>recently added</p>
</details></div></div><div class='docblock hidden'><p>Uses borrowed data to replace owned data, usually by cloning. <a href="https://doc.rust-lang.org/nightly/alloc/borrow/trait.ToOwned.html#method.clone_into">Read more</a></p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryFrom%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.Into.html" title="trait core::convert::Into">Into</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryFrom%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#581-590" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Error" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" class="type">Error</a> = <a class="enum" href="https://doc.rust-lang.org/nightly/core/convert/enum.Infallible.html" title="enum core::convert::Infallible">Infallible</a></code><a href="#associatedtype.Error" class="anchor"></a></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_from" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#tymethod.try_from" class="fnname">try_from</a>(value: U) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;T, &lt;T as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;U&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_from" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#587" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details><details class="rustdoc-toggle implementors-toggle" open><summary><h3 id="impl-TryInto%3CU%3E" class="impl"><code class="in-band">impl&lt;T, U&gt; <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html" title="trait core::convert::TryInto">TryInto</a>&lt;U&gt; for T <span class="where fmt-newline">where<br>&nbsp;&nbsp;&nbsp;&nbsp;U: <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;,&nbsp;</span></code><a href="#impl-TryInto%3CU%3E" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#567-576" title="goto source code">[src]</a></h3></summary><div class="impl-items"><h4 id="associatedtype.Error-1" class="type trait-impl"><code>type <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#associatedtype.Error" class="type">Error</a> = &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a></code><a href="#associatedtype.Error-1" class="anchor"></a></h4><div class='docblock'><p>The type returned in the event of a conversion error.</p>
</div><h4 id="method.try_into" class="method hidden trait-impl"><code>pub fn <a href="https://doc.rust-lang.org/nightly/core/convert/trait.TryInto.html#tymethod.try_into" class="fnname">try_into</a>(self) -&gt; <a class="enum" href="https://doc.rust-lang.org/nightly/core/result/enum.Result.html" title="enum core::result::Result">Result</a>&lt;U, &lt;U as <a class="trait" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html" title="trait core::convert::TryFrom">TryFrom</a>&lt;T&gt;&gt;::<a class="type" href="https://doc.rust-lang.org/nightly/core/convert/trait.TryFrom.html#associatedtype.Error" title="type core::convert::TryFrom::Error">Error</a>&gt;</code><a href="#method.try_into" class="anchor"></a><a class="srclink" href="https://doc.rust-lang.org/nightly/src/core/convert/mod.rs.html#573" title="goto source code">[src]</a></h4><div class='docblock hidden'><p>Performs the conversion.</p>
</div></div></details></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="wast" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script></body></html>