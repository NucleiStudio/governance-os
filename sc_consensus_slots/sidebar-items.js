initSidebarItems({"constant":[["MAX_SLOT_CAPACITY","We keep at least this number of slots in database."],["PRUNING_BOUND","We prune slots when they reach this number."]],"enum":[["CheckedHeader","A header which has been checked"]],"fn":[["check_equivocation","Checks if the header is an equivocation and returns the proof in that case."],["slot_lenience_exponential","Calculate a slot duration lenience based on the number of missed slots from current to parent. If the number of skipped slots is greated than 0 this method will apply an exponential backoff of at most `2^7 * slot_duration`, if no slots were skipped this method will return `None.`"],["slot_lenience_linear","Calculate a slot duration lenience based on the number of missed slots from current to parent. If the number of skipped slots is greated than 0 this method will apply a linear backoff of at most `20 * slot_duration`, if no slots were skipped this method will return `None.`"],["start_slot_worker","Start a new slot worker."]],"struct":[["SignedDuration","A `Duration` with a sign (before or after).  Immutable."],["SlotDuration","A slot duration. Create with `get_or_compute`."],["SlotInfo","Information about a slot."]],"trait":[["SimpleSlotWorker","A skeleton implementation for `SlotWorker` which tries to claim a slot at its beginning and tries to produce a block if successfully claimed, timing out if block production takes too long."],["SlotCompatible","Slot compatible inherent data."],["SlotWorker","A worker that should be invoked at every new slot."]],"type":[["StorageChanges","The changes that need to applied to the storage to create the state for a block."]]});