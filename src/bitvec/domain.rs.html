<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.17.4/src/domain.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>domain.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">/*! Data Model for Bit Sequence Domains

The domains governed by `BitSlice` and owned-variant handles have different
representative states depending on the span of governed elements and live bits.

This module provides representations of the domain states for ease of use by
handle operations.
!*/</span>

<span class="kw">use</span> <span class="kw">crate</span>::{
	<span class="ident">indices</span>::{
		<span class="ident">BitIdx</span>,
		<span class="ident">BitTail</span>,
	},
	<span class="ident">pointer</span>::<span class="ident">BitPtr</span>,
	<span class="ident">store</span>::<span class="ident">BitStore</span>,
};

<span class="kw">use</span> <span class="ident">either</span>::<span class="ident">Either</span>;

<span class="doccomment">/** Alias for the region components produced by the `BitDomain::splat` method.

Splatting a domain will produce either a `(head, element, tail)` tuple when the
region is contained entirely within a single element, or a much more complex
tuple of the head partial element, the body whole elements, and the tail partial
element.

# Types

- `T`: The backing storage the splat is describing.

# Lifetimes

- `&#39;a`: The backing storage the splat is describing.
**/</span>
<span class="comment">//  Type bounds in `type` aliases are disallowed, so `T::Access` is not writable</span>
<span class="comment">//  here.</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">type</span> <span class="ident">Splat</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span>, <span class="ident">A</span><span class="op">&gt;</span> <span class="op">=</span> <span class="ident">Either</span><span class="op">&lt;</span>(
	<span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">A</span>)<span class="op">&gt;</span>,
	<span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">A</span>]<span class="op">&gt;</span>,
	<span class="prelude-ty">Option</span><span class="op">&lt;</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">A</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)<span class="op">&gt;</span>,
), (<span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">A</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>)<span class="op">&gt;</span>;

<span class="doccomment">/** Representations of the state of the bit domain in its containing elements.

# Lifetimes

- `&#39;a`: Lifetime of the containing storage

# Type Parameters

- `T: BitStore` The type of the elements the domain inhabits.
**/</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Debug</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">enum</span> <span class="ident">BitDomain</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="lifetime">&#39;a</span> <span class="op">+</span> <span class="ident">BitStore</span> {
	<span class="doccomment">/// Empty domain.</span>
	<span class="ident">Empty</span>,
	<span class="doccomment">/// Single element domain which does not reach either edge.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Members</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: index of the first live domain bit in the element</span>
	<span class="doccomment">/// - `.1`: mutable reference to the element contatining the domain</span>
	<span class="doccomment">/// - `.2`: index of the first dead bit after the domain</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This variant is produced when the domain is contained entirely inside</span>
	<span class="doccomment">/// one element, and does not reach to either edge.</span>
	<span class="ident">Minor</span>(<span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span>::<span class="ident">Access</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>),
	<span class="doccomment">/// Multpile element domain which does not reach the edge of its edge</span>
	<span class="doccomment">/// elements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Members</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: index of the first live domain bit in the first element</span>
	<span class="doccomment">/// - `.1`: mutable reference to the partial head edge element</span>
	<span class="doccomment">/// - `.2`: mutable slice handle to the fully-live elements in the interior.</span>
	<span class="doccomment">///   This may be empty.</span>
	<span class="doccomment">/// - `.3`: mutable reference to the partial tail edge element</span>
	<span class="doccomment">/// - `.4`: index of the first dead bit after the domain</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This variant is produced when the domain uses at least two elements, and</span>
	<span class="doccomment">/// reaches neither the head edge of the head element nor the tail edge of</span>
	<span class="doccomment">/// the tail element.</span>
	<span class="ident">Major</span>(<span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span>::<span class="ident">Access</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">T</span>::<span class="ident">Access</span>], <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span>::<span class="ident">Access</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>),
	<span class="doccomment">/// Domain with a partial head cursor and fully extended tail cursor.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Members</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: index of the first live bit in the head element</span>
	<span class="doccomment">/// - `.1`: mutable reference to the partial head element</span>
	<span class="doccomment">/// - `.2`: mutable reference to the full elements of the domain. This may</span>
	<span class="doccomment">///   be empty.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This variant is produced when the domain’s head cursor is past `0`, and</span>
	<span class="doccomment">/// its tail cursor is exactly `T::BITS`.</span>
	<span class="ident">PartialHead</span>(<span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span>::<span class="ident">Access</span>, <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">T</span>::<span class="ident">Access</span>]),
	<span class="doccomment">/// Domain with a fully extended head cursor and partial tail cursor.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Members</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: mutable reference to the full elements of the domain. This may</span>
	<span class="doccomment">///   be empty.</span>
	<span class="doccomment">/// - `.1`: mutable reference to the partial tail element</span>
	<span class="doccomment">/// - `.2`: index of the first dead bit after the live bits in the tail</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This variant is produced when the domain’s head cursor is exactly `0`,</span>
	<span class="doccomment">/// and its tail cursor is less than `T::BITS`.</span>
	<span class="ident">PartialTail</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">T</span>::<span class="ident">Access</span>], <span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> <span class="ident">T</span>::<span class="ident">Access</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>),
	<span class="doccomment">/// Domain which fully spans its containing elements.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Members</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: mutable slice handle to the elements containing the domain</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Behavior</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This variant is produced when the all elements in the domain are fully</span>
	<span class="doccomment">/// populated.</span>
	<span class="ident">Spanning</span>(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a</span> [<span class="ident">T</span>::<span class="ident">Access</span>]),
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitDomain</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Unpacks a domain into components.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This is useful for deduplicating code that uses each region component</span>
	<span class="doccomment">/// but does not otherwise branch on region kind.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The `Minor` case returns a tuple of the head index, the element, and the</span>
	<span class="doccomment">/// tail index; all other cases return a tuple of optional:</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - head element, and start index in that element</span>
	<span class="doccomment">/// - body slice</span>
	<span class="doccomment">/// - tail element, and end index in that element</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">splat</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">Splat</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span>, <span class="ident">T</span>::<span class="ident">Access</span><span class="op">&gt;</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">Empty</span> <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Left</span>((<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>)),
			<span class="ident">BitDomain</span>::<span class="ident">Minor</span>(<span class="ident">h</span>, <span class="ident">e</span>, <span class="ident">t</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Right</span>((<span class="ident">h</span>, <span class="ident">e</span>, <span class="ident">t</span>)),
			<span class="ident">BitDomain</span>::<span class="ident">Major</span>(<span class="ident">h</span>, <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>, <span class="ident">t</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Left</span>((
				<span class="prelude-val">Some</span>((<span class="ident">h</span>, <span class="ident">head</span>)),
				<span class="prelude-val">Some</span>(<span class="ident">body</span>),
				<span class="prelude-val">Some</span>((<span class="ident">tail</span>, <span class="ident">t</span>)),
			)),
			<span class="ident">BitDomain</span>::<span class="ident">PartialHead</span>(<span class="ident">h</span>, <span class="ident">head</span>, <span class="ident">body</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Left</span>((
				<span class="prelude-val">Some</span>((<span class="ident">h</span>, <span class="ident">head</span>)),
				<span class="prelude-val">Some</span>(<span class="ident">body</span>),
				<span class="prelude-val">None</span>,
			)),
			<span class="ident">BitDomain</span>::<span class="ident">PartialTail</span>(<span class="ident">body</span>, <span class="ident">tail</span>, <span class="ident">t</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Left</span>((
				<span class="prelude-val">None</span>,
				<span class="prelude-val">Some</span>(<span class="ident">body</span>),
				<span class="prelude-val">Some</span>((<span class="ident">tail</span>, <span class="ident">t</span>)),
			)),
			<span class="ident">BitDomain</span>::<span class="ident">Spanning</span>(<span class="ident">body</span>) <span class="op">=</span><span class="op">&gt;</span> <span class="ident">Either</span>::<span class="ident">Left</span>((<span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(<span class="ident">body</span>), <span class="prelude-val">None</span>)),
		}
	}

	<span class="doccomment">/// Tests if the variant is `Minor`.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_minor</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">Minor</span>(..) <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">true</span>,
			<span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">false</span>,
		}
	}

	<span class="doccomment">/// Tests if the variant is `Major`.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_major</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">Major</span>(..) <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">true</span>,
			<span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">false</span>,
		}
	}

	<span class="doccomment">/// Tests if the variant is `PartialHead`.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_partial_head</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">PartialHead</span>(..) <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">true</span>,
			<span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">false</span>,
		}
	}

	<span class="doccomment">/// Tests if the variant is `PartialTail`.</span>
	<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_partial_tail</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">PartialTail</span>(..) <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">true</span>,
			<span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">false</span>,
		}
	}

	<span class="doccomment">/// Tests if the variant is `Spanning`.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">is_spanning</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">bool</span> {
		<span class="kw">match</span> <span class="self">self</span> {
			<span class="ident">BitDomain</span>::<span class="ident">Spanning</span>(..) <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">true</span>,
			<span class="kw">_</span> <span class="op">=</span><span class="op">&gt;</span> <span class="bool-val">false</span>,
		}
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span> <span class="ident">From</span><span class="op">&lt;</span><span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">BitDomain</span><span class="op">&lt;</span><span class="lifetime">&#39;a</span>, <span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="lifetime">&#39;a</span> <span class="op">+</span> <span class="ident">BitStore</span> {
	<span class="kw">fn</span> <span class="ident">from</span>(<span class="ident">bitptr</span>: <span class="ident">BitPtr</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="kw">let</span> <span class="ident">h</span> <span class="op">=</span> <span class="ident">bitptr</span>.<span class="ident">head</span>();
		<span class="kw">let</span> (<span class="ident">e</span>, <span class="ident">t</span>) <span class="op">=</span> <span class="ident">h</span>.<span class="ident">span</span>(<span class="ident">bitptr</span>.<span class="ident">len</span>());
		<span class="kw">let</span> <span class="ident">w</span> <span class="op">=</span> <span class="ident">T</span>::<span class="ident">BITS</span>;
		<span class="kw">let</span> <span class="ident">data</span> <span class="op">=</span> <span class="ident">bitptr</span>.<span class="ident">as_access_slice</span>();

		<span class="kw">match</span> (<span class="kw-2">*</span><span class="ident">h</span>, <span class="ident">e</span>, <span class="kw-2">*</span><span class="ident">t</span>) {
			<span class="comment">//  Empty.</span>
			(<span class="kw">_</span>, <span class="number">0</span>, <span class="kw">_</span>)           <span class="op">=</span><span class="op">&gt;</span> <span class="ident">BitDomain</span>::<span class="ident">Empty</span>,
			<span class="comment">//  Reaches both edges, for any number of elements.</span>
			(<span class="number">0</span>, <span class="kw">_</span>, <span class="ident">t</span>) <span class="kw">if</span> <span class="ident">t</span> <span class="op">=</span><span class="op">=</span> <span class="ident">w</span> <span class="op">=</span><span class="op">&gt;</span>
				<span class="ident">BitDomain</span>::<span class="ident">Spanning</span>(<span class="ident">data</span>),
			<span class="comment">//  Reaches only the tail edge, for any number of elements.</span>
			(<span class="kw">_</span>, <span class="kw">_</span>, <span class="ident">t</span>) <span class="kw">if</span> <span class="ident">t</span> <span class="op">=</span><span class="op">=</span> <span class="ident">w</span> <span class="op">=</span><span class="op">&gt;</span> {
				<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">data</span>
					.<span class="ident">split_first</span>()
					.<span class="ident">expect</span>(<span class="string">&quot;PartialHead cannot fail to split&quot;</span>);
				<span class="ident">BitDomain</span>::<span class="ident">PartialHead</span>(<span class="ident">h</span>, <span class="ident">head</span>, <span class="ident">rest</span>)
			},
			<span class="comment">//  Reaches only the head edge, for any number of elements.</span>
			(<span class="number">0</span>, <span class="kw">_</span>, <span class="kw">_</span>)           <span class="op">=</span><span class="op">&gt;</span> {
				<span class="kw">let</span> (<span class="ident">tail</span>, <span class="ident">rest</span>) <span class="op">=</span> <span class="ident">data</span>
					.<span class="ident">split_last</span>()
					.<span class="ident">expect</span>(<span class="string">&quot;PartialTail cannot fail to split&quot;</span>);
				<span class="ident">BitDomain</span>::<span class="ident">PartialTail</span>(<span class="ident">rest</span>, <span class="ident">tail</span>, <span class="ident">t</span>)
			},
			<span class="comment">//  Reaches neither edge, for only one element.</span>
			(<span class="kw">_</span>, <span class="number">1</span>, <span class="kw">_</span>)           <span class="op">=</span><span class="op">&gt;</span> <span class="ident">BitDomain</span>::<span class="ident">Minor</span>(<span class="ident">h</span>, <span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="ident">t</span>),
			<span class="comment">//  Reaches neither edge, for multiple elements.</span>
			(<span class="kw">_</span>, <span class="kw">_</span>, <span class="kw">_</span>)           <span class="op">=</span><span class="op">&gt;</span> {
				<span class="kw">let</span> (<span class="ident">head</span>, <span class="ident">body</span>) <span class="op">=</span> <span class="ident">data</span>
					.<span class="ident">split_first</span>()
					.<span class="ident">expect</span>(<span class="string">&quot;Major cannot fail to split the head element&quot;</span>);
				<span class="kw">let</span> (<span class="ident">tail</span>, <span class="ident">body</span>) <span class="op">=</span> <span class="ident">body</span>
					.<span class="ident">split_last</span>()
					.<span class="ident">expect</span>(<span class="string">&quot;Major cannot fail to split the tail element&quot;</span>);
				<span class="ident">BitDomain</span>::<span class="ident">Major</span>(<span class="ident">h</span>, <span class="ident">head</span>, <span class="ident">body</span>, <span class="ident">tail</span>, <span class="ident">t</span>)
			},
		}
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;
	<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">indices</span>::<span class="ident">Indexable</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">minor</span>() {
		<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">0u8</span>;
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="number">1u8</span>.<span class="ident">idx</span>(), <span class="number">6</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_minor</span>());
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">major</span>() {
		<span class="kw">let</span> <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u16</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0u16</span>, <span class="op">!</span><span class="number">0u16</span>];
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="number">1u8</span>.<span class="ident">idx</span>(), <span class="number">28</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_major</span>());
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">partial_head</span>() {
		<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">0u32</span>;
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="number">4u8</span>.<span class="ident">idx</span>(), <span class="number">28</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_partial_head</span>());

		<span class="kw">let</span> <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0u32</span>, <span class="op">!</span><span class="number">0u32</span>];
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="number">4u8</span>.<span class="ident">idx</span>(), <span class="number">60</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_partial_head</span>());
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">partial_tail</span>() {
		<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">u32</span> <span class="op">=</span> <span class="number">0u32</span>;
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="number">0u8</span>.<span class="ident">idx</span>(), <span class="number">60</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_partial_tail</span>());

		<span class="kw">let</span> <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u32</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0u32</span>, <span class="op">!</span><span class="number">0u32</span>];
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="number">0u8</span>.<span class="ident">idx</span>(), <span class="number">60</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_partial_tail</span>());
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">spanning</span>() {
		<span class="kw">let</span> <span class="ident">data</span>: <span class="ident">u8</span> <span class="op">=</span> <span class="number">0u8</span>;
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>, <span class="number">0u8</span>.<span class="ident">idx</span>(), <span class="number">8</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_spanning</span>());

		<span class="kw">let</span> <span class="ident">data</span>: <span class="kw-2">&amp;</span>[<span class="ident">u16</span>] <span class="op">=</span> <span class="kw-2">&amp;</span>[<span class="number">0u16</span>, <span class="op">!</span><span class="number">0u16</span>];
		<span class="kw">let</span> <span class="ident">bp</span> <span class="op">=</span> <span class="ident">BitPtr</span>::<span class="ident">new</span>(<span class="kw-2">&amp;</span><span class="ident">data</span>[<span class="number">0</span>], <span class="number">0u8</span>.<span class="ident">idx</span>(), <span class="number">32</span>);

		<span class="macro">assert</span><span class="macro">!</span>(<span class="ident">bp</span>.<span class="ident">domain</span>().<span class="ident">is_spanning</span>());
	}
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "bitvec";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>