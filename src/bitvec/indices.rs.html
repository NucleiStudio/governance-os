<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source to the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/bitvec-0.17.4/src/indices.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>indices.rs.html -- source</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script src="../../storage.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="icon" type="image/svg+xml" href="../../favicon.svg">
<link rel="alternate icon" type="image/png" href="../../favicon-16x16.png">
<link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc source"><!--[if lte IE 8]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu">&#9776;</div><a href='../../bitvec/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!"><img src="../../brush.svg" width="18" alt="Pick another theme!"></button><div id="theme-choices"></div></div><script src="../../theme.js"></script><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><span class="help-button">?</span>
                <a id="settings-menu" href="../../settings.html"><img src="../../wheel.svg" width="18" alt="Change settings"></a></div></form></nav><section id="main" class="content"><pre class="line-numbers"><span id="1">  1</span>
<span id="2">  2</span>
<span id="3">  3</span>
<span id="4">  4</span>
<span id="5">  5</span>
<span id="6">  6</span>
<span id="7">  7</span>
<span id="8">  8</span>
<span id="9">  9</span>
<span id="10"> 10</span>
<span id="11"> 11</span>
<span id="12"> 12</span>
<span id="13"> 13</span>
<span id="14"> 14</span>
<span id="15"> 15</span>
<span id="16"> 16</span>
<span id="17"> 17</span>
<span id="18"> 18</span>
<span id="19"> 19</span>
<span id="20"> 20</span>
<span id="21"> 21</span>
<span id="22"> 22</span>
<span id="23"> 23</span>
<span id="24"> 24</span>
<span id="25"> 25</span>
<span id="26"> 26</span>
<span id="27"> 27</span>
<span id="28"> 28</span>
<span id="29"> 29</span>
<span id="30"> 30</span>
<span id="31"> 31</span>
<span id="32"> 32</span>
<span id="33"> 33</span>
<span id="34"> 34</span>
<span id="35"> 35</span>
<span id="36"> 36</span>
<span id="37"> 37</span>
<span id="38"> 38</span>
<span id="39"> 39</span>
<span id="40"> 40</span>
<span id="41"> 41</span>
<span id="42"> 42</span>
<span id="43"> 43</span>
<span id="44"> 44</span>
<span id="45"> 45</span>
<span id="46"> 46</span>
<span id="47"> 47</span>
<span id="48"> 48</span>
<span id="49"> 49</span>
<span id="50"> 50</span>
<span id="51"> 51</span>
<span id="52"> 52</span>
<span id="53"> 53</span>
<span id="54"> 54</span>
<span id="55"> 55</span>
<span id="56"> 56</span>
<span id="57"> 57</span>
<span id="58"> 58</span>
<span id="59"> 59</span>
<span id="60"> 60</span>
<span id="61"> 61</span>
<span id="62"> 62</span>
<span id="63"> 63</span>
<span id="64"> 64</span>
<span id="65"> 65</span>
<span id="66"> 66</span>
<span id="67"> 67</span>
<span id="68"> 68</span>
<span id="69"> 69</span>
<span id="70"> 70</span>
<span id="71"> 71</span>
<span id="72"> 72</span>
<span id="73"> 73</span>
<span id="74"> 74</span>
<span id="75"> 75</span>
<span id="76"> 76</span>
<span id="77"> 77</span>
<span id="78"> 78</span>
<span id="79"> 79</span>
<span id="80"> 80</span>
<span id="81"> 81</span>
<span id="82"> 82</span>
<span id="83"> 83</span>
<span id="84"> 84</span>
<span id="85"> 85</span>
<span id="86"> 86</span>
<span id="87"> 87</span>
<span id="88"> 88</span>
<span id="89"> 89</span>
<span id="90"> 90</span>
<span id="91"> 91</span>
<span id="92"> 92</span>
<span id="93"> 93</span>
<span id="94"> 94</span>
<span id="95"> 95</span>
<span id="96"> 96</span>
<span id="97"> 97</span>
<span id="98"> 98</span>
<span id="99"> 99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
</pre><div class="example-wrap"><pre class="rust ">
<span class="doccomment">/*! Element bit indexing.

This module provides strong indexing types to manage the concept of addressing
bits inside spans of memory elements. The crate needs to have a concept of bit
positions that exist in memory (`BitIdx`), abstract “dead” bits that mark the
first bit past the end of a memory region and are not required to exist in
hardware (`BitTail`), specific bit positions that may be accessed by machine
instructions (`BitPos`), and element values that mask one or more bits of
interest (`BitMask`).
!*/</span>

<span class="kw">use</span> <span class="kw">crate</span>::<span class="ident">store</span>::<span class="ident">BitStore</span>;

<span class="kw">use</span> <span class="ident">core</span>::{
	<span class="ident">marker</span>::<span class="ident">PhantomData</span>,
	<span class="ident">ops</span>::<span class="ident">Deref</span>,
};

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;serde&quot;</span>)]</span>
<span class="kw">use</span> <span class="ident">core</span>::<span class="ident">convert</span>::<span class="ident">TryFrom</span>;

<span class="doccomment">/** Indicates a semantic index of a bit within a memory element.

This type is consumed by [`BitOrder`] implementors, which use it to produce a
concrete bit position inside an element.

`BitIdx` is a semantic counter which has a defined, constant, and predictable
ordering. Values of `BitIdx` refer strictly to an abstract ordering, and not to
any actual bit positions within a memory element, so `BitIdx::&lt;T&gt;(0)` is always
the first bit counted within an element, but is not required to be the most or
least significant bits, or any other particular bits. Which specific bit is
referred by a `BitIdx` value is governed by implementors of `BitOrder`.

# Type Parameters

- `T`: The memory element type controlled by this index.

[`BitOrder`]: ../order/trait.BitOrder.html
**/</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Semantic index within an element. Constrained to `0 .. T::BITS`.</span>
	<span class="ident">idx</span>: <span class="ident">u8</span>,
	<span class="doccomment">/// Marker for the indexed type.</span>
	<span class="ident">_ty</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Wraps a counter value as a known-good index of the `T` element type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `idx`: A semantic index within a `T` memory element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// If `idx` is within the range `0 .. T::BITS`, then this returns the index</span>
	<span class="doccomment">/// value wrapped in the index type; if `idx` exceeds this range, then this</span>
	<span class="doccomment">/// returns `None`.</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">idx</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Option</span><span class="op">&lt;</span><span class="self">Self</span><span class="op">&gt;</span> {
		<span class="kw">if</span> <span class="ident">idx</span> <span class="op">&gt;</span><span class="op">=</span> <span class="ident">T</span>::<span class="ident">BITS</span> {
			<span class="kw">return</span> <span class="prelude-val">None</span>;
		}
		<span class="prelude-val">Some</span>(<span class="kw">unsafe</span> { <span class="self">Self</span>::<span class="ident">new_unchecked</span>(<span class="ident">idx</span>) })
	}

	<span class="doccomment">/// Wraps a counter value as a known-good index of the `T` element type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `idx`: A semantic index within a `T` memory element. It must be in the</span>
	<span class="doccomment">///   range `0 .. T::BITS`.</span>
	<span class="attribute">#[<span class="ident">doc</span>(<span class="ident">hidden</span>)]</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">idx</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">debug_assert</span><span class="macro">!</span>(
			<span class="ident">idx</span> <span class="op">&lt;</span> <span class="ident">T</span>::<span class="ident">BITS</span>,
			<span class="string">&quot;Bit index {} cannot exceed type width {}&quot;</span>,
			<span class="ident">idx</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span>,
		);
		<span class="self">Self</span> { <span class="ident">idx</span>, <span class="ident">_ty</span>: <span class="ident">PhantomData</span> }
	}

	<span class="doccomment">/// Finds the destination bit a certain distance away from a starting bit.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This produces the number of elements to move from the starting point,</span>
	<span class="doccomment">/// and then the bit index of the destination bit in the destination</span>
	<span class="doccomment">/// element.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `self`: A bit index in some memory element, used as the starting</span>
	<span class="doccomment">///   position for the offset calculation.</span>
	<span class="doccomment">/// - `by`: The number of bits by which to move. Negative values move</span>
	<span class="doccomment">///   downwards in memory: towards index zero, then counting from index</span>
	<span class="doccomment">///   `T::MASK` to index zero in the next element lower in memory, repeating</span>
	<span class="doccomment">///   until arrival. Positive values move upwards in memory: towards index</span>
	<span class="doccomment">///   `T::MASK`, then counting from index zero to index `T::MASK` in the</span>
	<span class="doccomment">///   next element higher in memory, repeating until arrival.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: The number of elements by which to offset the caller’s element</span>
	<span class="doccomment">///   cursor. This value can be passed directly into [`ptr::offset`].</span>
	<span class="doccomment">/// - `.1`: The bit index of the destination bit in the element selected by</span>
	<span class="doccomment">///   applying the `.0` pointer offset.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `by` must not be far enough to cause the returned element offset value</span>
	<span class="doccomment">/// to, when applied to the original memory address via [`ptr::offset`],</span>
	<span class="doccomment">/// produce a reference out of bounds of the original allocation. This</span>
	<span class="doccomment">/// method has no way of checking this requirement.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`ptr::offset`]: https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.offset</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">offset</span>(<span class="self">self</span>, <span class="ident">by</span>: <span class="ident">isize</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">isize</span>, <span class="self">Self</span>) {
		<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="kw-2">*</span><span class="self">self</span>;

		<span class="comment">//  Signed-add `*self` and the jump distance. Overflowing is the</span>
		<span class="comment">//  unlikely branch. The result is a bit index, and an overflow marker.</span>
		<span class="comment">//  `far` is permitted to be negative; this means that it is lower in</span>
		<span class="comment">//  memory than the origin bit. The number line has its origin at the</span>
		<span class="comment">//  front edge of the origin element, so `-1` is the *last* bit of the</span>
		<span class="comment">//  prior memory element.</span>
		<span class="kw">let</span> (<span class="ident">far</span>, <span class="ident">ovf</span>) <span class="op">=</span> <span class="ident">by</span>.<span class="ident">overflowing_add</span>(<span class="ident">val</span> <span class="kw">as</span> <span class="ident">isize</span>);
		<span class="comment">//  If the `isize` addition does not overflow, then the sum can be used</span>
		<span class="comment">//  directly.</span>
		<span class="kw">if</span> <span class="op">!</span><span class="ident">ovf</span> {
			<span class="comment">//  If `far` is in the origin element, then the jump moves zero</span>
			<span class="comment">//  elements and produces `far` as an absolute index directly.</span>
			<span class="kw">if</span> (<span class="number">0</span> .. <span class="ident">T</span>::<span class="ident">BITS</span> <span class="kw">as</span> <span class="ident">isize</span>).<span class="ident">contains</span>(<span class="kw-2">&amp;</span><span class="ident">far</span>) {
				(<span class="number">0</span>, (<span class="ident">far</span> <span class="kw">as</span> <span class="ident">u8</span>).<span class="ident">idx</span>())
			}
			<span class="comment">//  Otherwise, downshift the bit distance to compute the number of</span>
			<span class="comment">//  elements moved in either direction, and mask to compute the</span>
			<span class="comment">//  absolute bit index in the destination element.</span>
			<span class="kw">else</span> {
				(<span class="ident">far</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">INDX</span>, (<span class="ident">far</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">&amp;</span> <span class="ident">T</span>::<span class="ident">MASK</span>).<span class="ident">idx</span>())
			}
		}
		<span class="kw">else</span> {
			<span class="comment">//  Overflowing `isize` addition happens to produce ordinary `usize`</span>
			<span class="comment">//  addition. In point of fact, `isize` addition and `usize`</span>
			<span class="comment">//  addition are the same machine instruction to perform the sum; it</span>
			<span class="comment">//  is merely the signed interpretation of the sum that differs. The</span>
			<span class="comment">//  sum can be recast back to `usize` without issue.</span>
			<span class="kw">let</span> <span class="ident">far</span> <span class="op">=</span> <span class="ident">far</span> <span class="kw">as</span> <span class="ident">usize</span>;
			<span class="comment">//  This is really only needed in order to prevent sign-extension of</span>
			<span class="comment">//  the downshift; once shifted, the value can be safely re-signed.</span>
			((<span class="ident">far</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">INDX</span>) <span class="kw">as</span> <span class="ident">isize</span>, (<span class="ident">far</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">&amp;</span> <span class="ident">T</span>::<span class="ident">MASK</span>).<span class="ident">idx</span>())
		}
	}

	<span class="doccomment">/// Computes the size of a span from `self` for `len` bits.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// Spans always extend upwards in memory.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `self`: The starting bit position of the span.</span>
	<span class="doccomment">/// - `len`: The number of bits to include in the span.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `.0`: The number of elements of `T` included in the span. If `len` is</span>
	<span class="doccomment">///   `0`, this will be `0`; otherwise, it will be at least one.</span>
	<span class="doccomment">/// - `.1`: The index of the first dead bit *after* the span. If `self` and</span>
	<span class="doccomment">///   `len` are both `0`, this will be `0`; otherwise, it will be in the</span>
	<span class="doccomment">///   domain `1 ..= T::BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Notes</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This defers to [`BitTail::span`], because `BitTail` is a strict superset</span>
	<span class="doccomment">/// of `BitIdx` (it is `{ BitIdx | T::BITS }`), and spans frequently begin</span>
	<span class="doccomment">/// from the tail of a slice in this crate. The `offset` function is *not*</span>
	<span class="doccomment">/// implemented on `BitTail`, and remains on `BitIdx` because offsets can</span>
	<span class="doccomment">/// only be computed from bit addresses that exist. It does not make sense</span>
	<span class="doccomment">/// to compute the offset from a `T::BITS` tail.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`BitTail::span`]: struct.BitTail.html#method.span</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">span</span>(<span class="self">self</span>, <span class="ident">len</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">usize</span>, <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>) {
		<span class="kw">unsafe</span> { <span class="ident">BitTail</span>::<span class="ident">new_unchecked</span>(<span class="kw-2">*</span><span class="self">self</span>) }.<span class="ident">span</span>(<span class="ident">len</span>)
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">u8</span>;

	<span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
		<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">idx</span>
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">feature</span> <span class="op">=</span> <span class="string">&quot;serde&quot;</span>)]</span>
<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">TryFrom</span><span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span> <span class="kw">for</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="kw">type</span> <span class="ident">Error</span> <span class="op">=</span> <span class="kw-2">&amp;</span><span class="lifetime">&#39;static</span> <span class="ident">str</span>;

	<span class="kw">fn</span> <span class="ident">try_from</span>(<span class="ident">idx</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span><span class="self">Self</span>, <span class="self">Self</span>::<span class="ident">Error</span><span class="op">&gt;</span> {
		<span class="kw">if</span> <span class="ident">idx</span> <span class="op">&lt;</span> <span class="ident">T</span>::<span class="ident">BITS</span> {
			<span class="prelude-val">Ok</span>(<span class="self">Self</span> { <span class="ident">idx</span>, <span class="ident">_ty</span>: <span class="ident">PhantomData</span> })
		}
		<span class="kw">else</span> {
			<span class="prelude-val">Err</span>(<span class="string">&quot;Attempted to construct a `BitIdx` with an index out of range&quot;</span>)
		}
	}
}

<span class="doccomment">/** Indicates a semantic index of a dead bit *beyond* a memory element.

This type is equivalent to `BitIdx&lt;T&gt;`, except that it includes `T::BITS` in its
domain. Instances of this type will only ever contain `0` when the span they
describe is *empty*. Non-empty spans always cycle through the domain
`1 ..= T::BITS`.

This type cannot be used for indexing, and does not translate to `BitPos&lt;T&gt;`.
This type has no behavior other than viewing its internal `u8` for arithmetic.

# Type Parameters

- `T`: The memory element type controlled by this tail.
**/</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">struct</span> <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Semantic index *after* an element. Constrained to `0 ..= T::BITS`.</span>
	<span class="ident">end</span>: <span class="ident">u8</span>,
	<span class="doccomment">/// Marker for the tailed type.</span>
	<span class="ident">_ty</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Mark that `end` is a tail index for a type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `end` must be in the range `0 ..= T::BITS`.</span>
	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">end</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">debug_assert</span><span class="macro">!</span>(
			<span class="ident">end</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">T</span>::<span class="ident">BITS</span>,
			<span class="string">&quot;Bit tail {} cannot surpass type width {}&quot;</span>,
			<span class="ident">end</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span>,
		);
		<span class="self">Self</span> { <span class="ident">end</span>, <span class="ident">_ty</span>: <span class="ident">PhantomData</span> }
	}

	<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">fn</span> <span class="ident">span</span>(<span class="self">self</span>, <span class="ident">len</span>: <span class="ident">usize</span>) <span class="op">-</span><span class="op">&gt;</span> (<span class="ident">usize</span>, <span class="self">Self</span>) {
		<span class="kw">let</span> <span class="ident">val</span> <span class="op">=</span> <span class="kw-2">*</span><span class="self">self</span>;
		<span class="macro">debug_assert</span><span class="macro">!</span>(
			<span class="ident">val</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">T</span>::<span class="ident">BITS</span>,
			<span class="string">&quot;Tail out of range: {} overflows type width {}&quot;</span>,
			<span class="ident">val</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span>,
		);

		<span class="kw">if</span> <span class="ident">len</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span> {
			<span class="kw">return</span> (<span class="number">0</span>, <span class="self">self</span>);
		}

		<span class="kw">let</span> <span class="ident">head</span> <span class="op">=</span> <span class="ident">val</span> <span class="op">&amp;</span> <span class="ident">T</span>::<span class="ident">MASK</span>;

		<span class="kw">let</span> <span class="ident">bits_in_head</span> <span class="op">=</span> (<span class="ident">T</span>::<span class="ident">BITS</span> <span class="op">-</span> <span class="ident">head</span>) <span class="kw">as</span> <span class="ident">usize</span>;

		<span class="kw">if</span> <span class="ident">len</span> <span class="op">&lt;</span><span class="op">=</span> <span class="ident">bits_in_head</span> {
			<span class="kw">return</span> (<span class="number">1</span>, (<span class="ident">head</span> <span class="op">+</span> <span class="ident">len</span> <span class="kw">as</span> <span class="ident">u8</span>).<span class="ident">tail</span>());
		}

		<span class="kw">let</span> <span class="ident">bits_after_head</span> <span class="op">=</span> <span class="ident">len</span> <span class="op">-</span> <span class="ident">bits_in_head</span>;

		<span class="kw">let</span> <span class="ident">elts</span> <span class="op">=</span> <span class="ident">bits_after_head</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">T</span>::<span class="ident">INDX</span>;
		<span class="kw">let</span> <span class="ident">tail</span> <span class="op">=</span> <span class="ident">bits_after_head</span> <span class="kw">as</span> <span class="ident">u8</span> <span class="op">&amp;</span> <span class="ident">T</span>::<span class="ident">MASK</span>;

		<span class="kw">let</span> <span class="ident">is_zero</span> <span class="op">=</span> (<span class="ident">tail</span> <span class="op">=</span><span class="op">=</span> <span class="number">0</span>) <span class="kw">as</span> <span class="ident">u8</span>;
		<span class="kw">let</span> <span class="ident">edges</span> <span class="op">=</span> <span class="number">2</span> <span class="op">-</span> <span class="ident">is_zero</span> <span class="kw">as</span> <span class="ident">usize</span>;
		(<span class="ident">elts</span> <span class="op">+</span> <span class="ident">edges</span>, ((<span class="ident">is_zero</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="ident">T</span>::<span class="ident">INDX</span>) <span class="op">|</span> <span class="ident">tail</span>).<span class="ident">tail</span>())

		<span class="comment">/* The above expression is the branchless equivalent of this structure:

		if tail == 0 {
			(elts + 1, T::BITS.tail())
		}
		else {
			(elts + 2, tail.tail())
		}
		*/</span>
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">u8</span>;

	<span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
		<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">end</span>
	}
}

<span class="doccomment">/** Indicates a real electrical index within an element.

This type is produced by [`BitOrder`] implementors, and marks a specific
electrical bit within a memory element, rather than `BitIdx`’s semantic bit.

# Type Parameters

- `T`: A `BitStore` element which provides bounds-checking information. The
  [`new`] constructor uses [`T::BITS`] to ensure that constructed `BitPos`
  instances are always valid to use within `T` elements.

[`BitOrder`]: ../order/trait.BitOrder.html
[`T::BITS`]: ../store/trait.BitStore.html#associatedconstant.BITS
[`new`]: #method.new
**/</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Electrical position within an element. Constrained to `0 .. T::BITS`.</span>
	<span class="ident">pos</span>: <span class="ident">u8</span>,
	<span class="doccomment">/// Marker for the positioned type.</span>
	<span class="ident">_ty</span>: <span class="ident">PhantomData</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Produce a new bit position marker at a valid position value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `BitOrder` implementations should prefer this method, but *may* use</span>
	<span class="doccomment">/// [`::new_unchecked`] if they can guarantee that the range invariant is</span>
	<span class="doccomment">/// upheld.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `pos`: The bit position value to encode. It must be in the range</span>
	<span class="doccomment">///   `0 .. T::BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function panics if `pos` is greater than or equal to `T::BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`::new_unchecked`]: #method.new_unchecked</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">pos</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">assert</span><span class="macro">!</span>(
			<span class="ident">pos</span> <span class="op">&lt;</span> <span class="ident">T</span>::<span class="ident">BITS</span>,
			<span class="string">&quot;Bit position {} cannot exceed type width {}&quot;</span>,
			<span class="ident">pos</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span>,
		);
		<span class="self">Self</span> { <span class="ident">pos</span>, <span class="ident">_ty</span>: <span class="ident">PhantomData</span> }
	}

	<span class="doccomment">/// Produce a new bit position marker at any position value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller *must* ensure that `pos` is less than `T::BITS`. `BitOrder`</span>
	<span class="doccomment">/// implementations should prefer [`::new`], which panics on range failure.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `pos`: The bit position value to encode. This must be in the range</span>
	<span class="doccomment">///   `0 .. T::BITS`.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `pos` wrapped in the `BitPos` marker type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function panics if `pos` is greater than or equal to `T::BITS`, but</span>
	<span class="doccomment">/// only in debug builds. It does not inspect `pos` in release builds.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`::new`]: #method.new</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">debug_assertions</span>, <span class="ident">inline</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">debug_assertions</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">pos</span>: <span class="ident">u8</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">debug_assert</span><span class="macro">!</span>(
			<span class="ident">pos</span> <span class="op">&lt;</span> <span class="ident">T</span>::<span class="ident">BITS</span>,
			<span class="string">&quot;Bit position {} cannot exceed type width {}&quot;</span>,
			<span class="ident">pos</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span>,
		);
		<span class="self">Self</span> { <span class="ident">pos</span>, <span class="ident">_ty</span>: <span class="ident">PhantomData</span> }
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">u8</span>;

	<span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
		<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">pos</span>
	}
}

<span class="doccomment">/** Wrapper type indicating a one-hot encoding of a bit mask for an element.

This type is produced by [`BitOrder`] implementations to speed up access to the
underlying memory. It ensures that masks have exactly one set bit, and can
safely be used as a mask for read/write access to memory.

# Type Parameters

- `T`: The storage type being masked.

[`BitOrder`]: ../order/trait.BitOrder.html
**/</span>
<span class="attribute">#[<span class="ident">derive</span>(<span class="ident">Clone</span>, <span class="ident">Copy</span>, <span class="ident">Debug</span>, <span class="ident">Default</span>, <span class="ident">Eq</span>, <span class="ident">Hash</span>, <span class="ident">Ord</span>, <span class="ident">PartialEq</span>, <span class="ident">PartialOrd</span>)]</span>
<span class="kw">pub</span> <span class="kw">struct</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Mask value.</span>
	<span class="ident">mask</span>: <span class="ident">T</span>,
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="doccomment">/// Produce a new bit-mask wrapper around a one-hot mask value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `BitOrder` implementations should prefer this method, but *may* use</span>
	<span class="doccomment">/// [`::new_unchecked`] if they can guarantee that the one-hot invariant is</span>
	<span class="doccomment">/// upheld.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `mask`: The mask value to encode. This **must** have exactly one bit</span>
	<span class="doccomment">///   set high, and all others set low.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `mask` wrapped in the `BitMask` marker type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function unconditionally panics if `mask` has zero or multiple bits</span>
	<span class="doccomment">/// set high.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`::new_unchecked`]: #method.new_unchecked</span>
	<span class="attribute">#[<span class="ident">inline</span>]</span>
	<span class="kw">pub</span> <span class="kw">fn</span> <span class="ident">new</span>(<span class="ident">mask</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">assert</span><span class="macro">!</span>(
			<span class="ident">mask</span>.<span class="ident">count_ones</span>() <span class="op">=</span><span class="op">=</span> <span class="number">1</span>,
			<span class="string">&quot;Masks are required to have exactly one set bit: {:0&gt;1$b}&quot;</span>,
			<span class="ident">mask</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span> <span class="kw">as</span> <span class="ident">usize</span>,
		);
		<span class="self">Self</span> { <span class="ident">mask</span> }
	}

	<span class="doccomment">/// Produce a new bit-mask wrapper around any value.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Safety</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// The caller *must* ensure that `mask` has exactly one bit set. `BitOrder`</span>
	<span class="doccomment">/// implementations should prefer [`::new`], which always panics on failure.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Parameters</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// - `mask`: The mask value to encode. This must have exactly one bit set.</span>
	<span class="doccomment">///   Failure to uphold this requirement will introduce uncontrolled state</span>
	<span class="doccomment">///   contamination.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Returns</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// `mask` wrapped in the `BitMask` marker type.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// # Panics</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// This function panics if `mask` has zero or multiple bits set, only in</span>
	<span class="doccomment">/// debug builds. It does not inspect `mask` in release builds.</span>
	<span class="doccomment">///</span>
	<span class="doccomment">/// [`::new`]: #method.new</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">debug_assertions</span>, <span class="ident">inline</span>)]</span>
	<span class="attribute">#[<span class="ident">cfg_attr</span>(<span class="ident">not</span>(<span class="ident">debug_assertions</span>), <span class="ident">inline</span>(<span class="ident">always</span>))]</span>
	<span class="kw">pub</span> <span class="kw">unsafe</span> <span class="kw">fn</span> <span class="ident">new_unchecked</span>(<span class="ident">mask</span>: <span class="ident">T</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="self">Self</span> {
		<span class="macro">debug_assert</span><span class="macro">!</span>(
			<span class="ident">mask</span>.<span class="ident">count_ones</span>() <span class="op">=</span><span class="op">=</span> <span class="number">1</span>,
			<span class="string">&quot;Masks are required to have exactly one set bit: {:0&gt;1$b}&quot;</span>,
			<span class="ident">mask</span>,
			<span class="ident">T</span>::<span class="ident">BITS</span> <span class="kw">as</span> <span class="ident">usize</span>,
		);
		<span class="self">Self</span> { <span class="ident">mask</span> }
	}
}

<span class="kw">impl</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span> <span class="ident">Deref</span> <span class="kw">for</span> <span class="ident">BitMask</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
	<span class="kw">type</span> <span class="ident">Target</span> <span class="op">=</span> <span class="ident">T</span>;

	<span class="kw">fn</span> <span class="ident">deref</span>(<span class="kw-2">&amp;</span><span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="kw-2">&amp;</span><span class="self">Self</span>::<span class="ident">Target</span> {
		<span class="kw-2">&amp;</span><span class="self">self</span>.<span class="ident">mask</span>
	}
}

<span class="doccomment">/** Internal convenience trait for wrapping numbers with appropriate markers.

This trait must only be used on values that are known to be valid for their
context. It provides an internal-only shorthand for wrapping integer literals
and known-good values in marker types.

It is only implemented on `u8`.
**/</span>
<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">trait</span> <span class="ident">Indexable</span> {
	<span class="doccomment">/// Wraps a value as a `BitIdx&lt;T&gt;`.</span>
	<span class="kw">fn</span> <span class="ident">idx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>;

	<span class="doccomment">/// Wraps a value as a `BitTail&lt;T&gt;`.</span>
	<span class="kw">fn</span> <span class="ident">tail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>;

	<span class="doccomment">/// Wraps a value as a `BitPos&lt;T&gt;`.</span>
	<span class="kw">fn</span> <span class="ident">pos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span>;
}

<span class="kw">impl</span> <span class="ident">Indexable</span> <span class="kw">for</span> <span class="ident">u8</span> {
	<span class="kw">fn</span> <span class="ident">idx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitIdx</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitIdx</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>::<span class="ident">new_unchecked</span>(<span class="self">self</span>) }
	}

	<span class="kw">fn</span> <span class="ident">tail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitTail</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitTail</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>::<span class="ident">new_unchecked</span>(<span class="self">self</span>) }
	}

	<span class="kw">fn</span> <span class="ident">pos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>(<span class="self">self</span>) <span class="op">-</span><span class="op">&gt;</span> <span class="ident">BitPos</span><span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>
	<span class="kw">where</span> <span class="ident">T</span>: <span class="ident">BitStore</span> {
		<span class="kw">unsafe</span> { <span class="ident">BitPos</span>::<span class="op">&lt;</span><span class="ident">T</span><span class="op">&gt;</span>::<span class="ident">new_unchecked</span>(<span class="self">self</span>) }
	}
}

<span class="attribute">#[<span class="ident">cfg</span>(<span class="ident">test</span>)]</span>
<span class="kw">mod</span> <span class="ident">tests</span> {
	<span class="kw">use</span> <span class="kw">super</span>::<span class="kw-2">*</span>;

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">jump_far_up</span>() {
		<span class="comment">//  isize::max_value() is 0x7f...ff, so the result bit will be one less</span>
		<span class="comment">//  than the start bit.</span>
		<span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">1</span> .. <span class="number">8</span> {
			<span class="kw">let</span> (<span class="ident">elt</span>, <span class="ident">bit</span>) <span class="op">=</span> <span class="ident">n</span>.<span class="ident">idx</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>().<span class="ident">offset</span>(<span class="ident">isize</span>::<span class="ident">max_value</span>());
			<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elt</span>, (<span class="ident">isize</span>::<span class="ident">max_value</span>() <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">u8</span>::<span class="ident">INDX</span>) <span class="op">+</span> <span class="number">1</span>);
			<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">bit</span>, <span class="ident">n</span> <span class="op">-</span> <span class="number">1</span>);
		}
		<span class="kw">let</span> (<span class="ident">elt</span>, <span class="ident">bit</span>) <span class="op">=</span> <span class="number">0u8</span>.<span class="ident">idx</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>().<span class="ident">offset</span>(<span class="ident">isize</span>::<span class="ident">max_value</span>());
		<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elt</span>, <span class="ident">isize</span>::<span class="ident">max_value</span>() <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">u8</span>::<span class="ident">INDX</span>);
		<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">bit</span>, <span class="number">7</span>);
	}

	<span class="attribute">#[<span class="ident">test</span>]</span>
	<span class="kw">fn</span> <span class="ident">jump_far_down</span>() {
		<span class="comment">//  isize::min_value() is 0x80...00, so the result bit will be equal to</span>
		<span class="comment">//  the start bit</span>
		<span class="kw">for</span> <span class="ident">n</span> <span class="kw">in</span> <span class="number">0</span> .. <span class="number">8</span> {
			<span class="kw">let</span> (<span class="ident">elt</span>, <span class="ident">bit</span>) <span class="op">=</span> <span class="ident">n</span>.<span class="ident">idx</span>::<span class="op">&lt;</span><span class="ident">u8</span><span class="op">&gt;</span>().<span class="ident">offset</span>(<span class="ident">isize</span>::<span class="ident">min_value</span>());
			<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="ident">elt</span>, <span class="ident">isize</span>::<span class="ident">min_value</span>() <span class="op">&gt;</span><span class="op">&gt;</span> <span class="ident">u8</span>::<span class="ident">INDX</span>);
			<span class="macro">assert_eq</span><span class="macro">!</span>(<span class="kw-2">*</span><span class="ident">bit</span>, <span class="ident">n</span>);
		}
	}
}
</pre></div>
</section><section id="search" class="content hidden"></section><section class="footer"></section><script>window.rootPath = "../../";window.currentCrate = "bitvec";</script><script src="../../main.js"></script><script src="../../source-script.js"></script><script src="../../source-files.js"></script><script defer src="../../search-index.js"></script></body></html>