initSidebarItems({"constant":[["AIO_PRIO_DELTA_MAX",""],["ARG_MAX",""],["BC_BASE_MAX",""],["BC_DIM_MAX",""],["BC_SCALE_MAX",""],["BC_STRING_MAX",""],["CHARCLASS_NAME_MAX",""],["COLL_WEIGHTS_MAX",""],["DELAYTIMER_MAX",""],["EXPR_NEST_MAX",""],["HOST_NAME_MAX",""],["LINE_MAX",""],["LINK_MAX",""],["LOGIN_NAME_MAX",""],["MAX_CANON",""],["MAX_INPUT",""],["MB_LEN_MAX",""],["MQ_PRIO_MAX",""],["NAME_MAX",""],["NGROUPS_MAX",""],["NR_OPEN",""],["PATH_MAX",""],["PIPE_BUF",""],["PTHREAD_DESTRUCTOR_ITERATIONS",""],["PTHREAD_KEYS_MAX",""],["PTHREAD_STACK_MIN",""],["RE_DUP_MAX",""],["RTSIG_MAX",""],["SEM_VALUE_MAX",""],["TTY_NAME_MAX",""],["XATTR_LIST_MAX",""],["XATTR_NAME_MAX",""],["XATTR_SIZE_MAX",""],["ZDICT_CONTENTSIZE_MIN",""],["ZDICT_DICTSIZE_MIN",""],["ZSTDMT_NBWORKERS_MAX",""],["ZSTD_BLOCKSIZELOG_MAX",""],["ZSTD_BLOCKSIZE_MAX",""],["ZSTD_CHAINLOG_MAX_32",""],["ZSTD_CHAINLOG_MAX_64",""],["ZSTD_CHAINLOG_MIN",""],["ZSTD_CLEVEL_DEFAULT",""],["ZSTD_CONTENTSIZE_ERROR",""],["ZSTD_CONTENTSIZE_UNKNOWN",""],["ZSTD_FRAMEHEADERSIZE_MAX",""],["ZSTD_HASHLOG3_MAX",""],["ZSTD_HASHLOG_MIN",""],["ZSTD_LDM_BUCKETSIZELOG_MAX",""],["ZSTD_LDM_BUCKETSIZELOG_MIN",""],["ZSTD_LDM_HASHLOG_MIN",""],["ZSTD_LDM_HASHRATELOG_MIN",""],["ZSTD_LDM_MINMATCH_MAX",""],["ZSTD_LDM_MINMATCH_MIN",""],["ZSTD_MAGICNUMBER",""],["ZSTD_MAGIC_DICTIONARY",""],["ZSTD_MAGIC_SKIPPABLE_MASK",""],["ZSTD_MAGIC_SKIPPABLE_START",""],["ZSTD_MINMATCH_MAX",""],["ZSTD_MINMATCH_MIN",""],["ZSTD_OVERLAPLOG_MAX",""],["ZSTD_OVERLAPLOG_MIN",""],["ZSTD_SEARCHLOG_MIN",""],["ZSTD_SKIPPABLEHEADERSIZE",""],["ZSTD_SRCSIZEHINT_MIN",""],["ZSTD_TARGETCBLOCKSIZE_MAX",""],["ZSTD_TARGETCBLOCKSIZE_MIN",""],["ZSTD_TARGETLENGTH_MAX",""],["ZSTD_TARGETLENGTH_MIN",""],["ZSTD_VERSION_MAJOR",""],["ZSTD_VERSION_MINOR",""],["ZSTD_VERSION_NUMBER",""],["ZSTD_VERSION_RELEASE",""],["ZSTD_WINDOWLOG_LIMIT_DEFAULT",""],["ZSTD_WINDOWLOG_MAX_32",""],["ZSTD_WINDOWLOG_MAX_64",""],["ZSTD_WINDOWLOG_MIN",""],["_ATFILE_SOURCE",""],["_BITS_POSIX1_LIM_H",""],["_BITS_POSIX2_LIM_H",""],["_BITS_TYPES_LOCALE_T_H",""],["_BITS_TYPES___LOCALE_T_H",""],["_DEFAULT_SOURCE",""],["_FEATURES_H",""],["_LIBC_LIMITS_H_",""],["_POSIX2_BC_BASE_MAX",""],["_POSIX2_BC_DIM_MAX",""],["_POSIX2_BC_SCALE_MAX",""],["_POSIX2_BC_STRING_MAX",""],["_POSIX2_CHARCLASS_NAME_MAX",""],["_POSIX2_COLL_WEIGHTS_MAX",""],["_POSIX2_EXPR_NEST_MAX",""],["_POSIX2_LINE_MAX",""],["_POSIX2_RE_DUP_MAX",""],["_POSIX_AIO_LISTIO_MAX",""],["_POSIX_AIO_MAX",""],["_POSIX_ARG_MAX",""],["_POSIX_CHILD_MAX",""],["_POSIX_CLOCKRES_MIN",""],["_POSIX_C_SOURCE",""],["_POSIX_DELAYTIMER_MAX",""],["_POSIX_HOST_NAME_MAX",""],["_POSIX_LINK_MAX",""],["_POSIX_LOGIN_NAME_MAX",""],["_POSIX_MAX_CANON",""],["_POSIX_MAX_INPUT",""],["_POSIX_MQ_OPEN_MAX",""],["_POSIX_MQ_PRIO_MAX",""],["_POSIX_NAME_MAX",""],["_POSIX_NGROUPS_MAX",""],["_POSIX_OPEN_MAX",""],["_POSIX_PATH_MAX",""],["_POSIX_PIPE_BUF",""],["_POSIX_RE_DUP_MAX",""],["_POSIX_RTSIG_MAX",""],["_POSIX_SEM_NSEMS_MAX",""],["_POSIX_SEM_VALUE_MAX",""],["_POSIX_SIGQUEUE_MAX",""],["_POSIX_SOURCE",""],["_POSIX_SSIZE_MAX",""],["_POSIX_STREAM_MAX",""],["_POSIX_SYMLINK_MAX",""],["_POSIX_SYMLOOP_MAX",""],["_POSIX_THREAD_DESTRUCTOR_ITERATIONS",""],["_POSIX_THREAD_KEYS_MAX",""],["_POSIX_THREAD_THREADS_MAX",""],["_POSIX_TIMER_MAX",""],["_POSIX_TTY_NAME_MAX",""],["_POSIX_TZNAME_MAX",""],["_STDC_PREDEF_H",""],["_STRINGS_H",""],["_STRING_H",""],["_SYS_CDEFS_H",""],["__GLIBC_MINOR__",""],["__GLIBC_USE_DEPRECATED_GETS",""],["__GLIBC_USE_DEPRECATED_SCANF",""],["__GLIBC_USE_IEC_60559_BFP_EXT",""],["__GLIBC_USE_IEC_60559_BFP_EXT_C2X",""],["__GLIBC_USE_IEC_60559_FUNCS_EXT",""],["__GLIBC_USE_IEC_60559_FUNCS_EXT_C2X",""],["__GLIBC_USE_IEC_60559_TYPES_EXT",""],["__GLIBC_USE_ISOC2X",""],["__GLIBC_USE_LIB_EXT2",""],["__GLIBC__",""],["__GNU_LIBRARY__",""],["__HAVE_GENERIC_SELECTION",""],["__LDOUBLE_REDIRECTS_TO_FLOAT128_ABI",""],["__STDC_IEC_559_COMPLEX__",""],["__STDC_IEC_559__",""],["__STDC_ISO_10646__",""],["__SYSCALL_WORDSIZE",""],["__USE_ATFILE",""],["__USE_FORTIFY_LEVEL",""],["__USE_ISOC11",""],["__USE_ISOC95",""],["__USE_ISOC99",""],["__USE_MISC",""],["__USE_POSIX",""],["__USE_POSIX199309",""],["__USE_POSIX199506",""],["__USE_POSIX2",""],["__USE_POSIX_IMPLICITLY",""],["__USE_XOPEN2K",""],["__USE_XOPEN2K8",""],["__WORDSIZE",""],["__WORDSIZE_TIME64_COMPAT32",""],["__glibc_c99_flexarr_available",""]],"enum":[["ZSTD_EndDirective",""],["ZSTD_ResetDirective",""],["ZSTD_cParameter",""],["ZSTD_dParameter","Advanced decompression API"],["ZSTD_dictAttachPref_e",""],["ZSTD_dictContentType_e",""],["ZSTD_dictLoadMethod_e",""],["ZSTD_forceIgnoreChecksum_e",""],["ZSTD_format_e",""],["ZSTD_frameType_e","Buffer-less streaming decompression (synchronous mode)"],["ZSTD_literalCompressionMode_e",""],["ZSTD_nextInputType_e",""],["ZSTD_sequenceFormat_e",""],["ZSTD_strategy","Advanced compression API"]],"fn":[["ZDICT_addEntropyTablesFromBuffer",""],["ZDICT_finalizeDictionary","ZDICT_finalizeDictionary(): Given a custom content as a basis for dictionary, and a set of samples, finalize dictionary by adding headers and statistics according to the zstd dictionary format."],["ZDICT_getDictHeaderSize",""],["ZDICT_getDictID",""],["ZDICT_getErrorName",""],["ZDICT_isError",""],["ZDICT_optimizeTrainFromBuffer_cover","ZDICT_optimizeTrainFromBuffer_cover(): The same requirements as above hold for all the parameters except `parameters`. This function tries many parameter combinations and picks the best parameters. `*parameters` is filled with the best parameters found, dictionary constructed with those parameters is stored in `dictBuffer`."],["ZDICT_optimizeTrainFromBuffer_fastCover","ZDICT_optimizeTrainFromBuffer_fastCover(): The same requirements as above hold for all the parameters except `parameters`. This function tries many parameter combinations (specifically, k and d combinations) and picks the best parameters. `*parameters` is filled with the best parameters found, dictionary constructed with those parameters is stored in `dictBuffer`. All of the parameters d, k, steps, f, and accel are optional. If d is non-zero then we don’t check multiple values of d, otherwise we check d = {6, 8}. if steps is zero it defaults to its default value. If k is non-zero then we don’t check multiple values of k, otherwise we check steps values in [50, 2000]. If f is zero, default value of 20 is used. If accel is zero, default value of 1 is used."],["ZDICT_trainFromBuffer","ZDICT_trainFromBuffer(): Train a dictionary from an array of samples. Redirect towards ZDICT_optimizeTrainFromBuffer_fastCover() single-threaded, with d=8, steps=4, f=20, and accel=1. Samples must be stored concatenated in a single flat buffer `samplesBuffer`, supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order. The resulting dictionary will be saved into `dictBuffer`. @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`) or an error code, which can be tested with ZDICT_isError(). Note:  Dictionary training will fail if there are not enough samples to construct a dictionary, or if most of the samples are too small (< 8 bytes being the lower limit). If dictionary training fails, you should use zstd without a dictionary, as the dictionary would’ve been ineffective anyways. If you believe your samples would benefit from a dictionary please open an issue with details, and we can look into it. Note: ZDICT_trainFromBuffer()’s memory usage is about 6 MB. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It’s possible to select smaller or larger size, just by specifying `dictBufferCapacity`. In general, it’s recommended to provide a few thousands samples, though this can vary a lot. It’s recommended that total size of all samples be about ~x100 times the target size of dictionary."],["ZDICT_trainFromBuffer_cover","ZDICT_trainFromBuffer_cover(): Train a dictionary from an array of samples using the COVER algorithm. Samples must be stored concatenated in a single flat buffer `samplesBuffer`, supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order. The resulting dictionary will be saved into `dictBuffer`. @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`) or an error code, which can be tested with ZDICT_isError(). See ZDICT_trainFromBuffer() for details on failure modes. Note: ZDICT_trainFromBuffer_cover() requires about 9 bytes of memory for each input byte. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It’s possible to select smaller or larger size, just by specifying `dictBufferCapacity`. In general, it’s recommended to provide a few thousands samples, though this can vary a lot. It’s recommended that total size of all samples be about ~x100 times the target size of dictionary."],["ZDICT_trainFromBuffer_fastCover","ZDICT_trainFromBuffer_fastCover(): Train a dictionary from an array of samples using a modified version of COVER algorithm. Samples must be stored concatenated in a single flat buffer `samplesBuffer`, supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order. d and k are required. All other parameters are optional, will use default values if not provided The resulting dictionary will be saved into `dictBuffer`. @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`) or an error code, which can be tested with ZDICT_isError(). See ZDICT_trainFromBuffer() for details on failure modes. Note: ZDICT_trainFromBuffer_fastCover() requires 6 * 2^f bytes of memory. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It’s possible to select smaller or larger size, just by specifying `dictBufferCapacity`. In general, it’s recommended to provide a few thousands samples, though this can vary a lot. It’s recommended that total size of all samples be about ~x100 times the target size of dictionary."],["ZDICT_trainFromBuffer_legacy","ZDICT_trainFromBuffer_legacy(): Train a dictionary from an array of samples. Samples must be stored concatenated in a single flat buffer `samplesBuffer`, supplied with an array of sizes `samplesSizes`, providing the size of each sample, in order. The resulting dictionary will be saved into `dictBuffer`. `parameters` is optional and can be provided with values set to 0 to mean “default”. @return: size of dictionary stored into `dictBuffer` (<= `dictBufferCapacity`) or an error code, which can be tested with ZDICT_isError(). See ZDICT_trainFromBuffer() for details on failure modes. Tips: In general, a reasonable dictionary has a size of ~ 100 KB. It’s possible to select smaller or larger size, just by specifying `dictBufferCapacity`. In general, it’s recommended to provide a few thousands samples, though this can vary a lot. It’s recommended that total size of all samples be about ~x100 times the target size of dictionary. Note: ZDICT_trainFromBuffer_legacy() will send notifications into stderr if instructed to, using notificationLevel>0."],["ZSTDMT_compressStream_generic","ZSTDMT_compressStream_generic() : Combines ZSTDMT_compressStream() with optional ZSTDMT_flushStream() or ZSTDMT_endStream() depending on flush directive. @return : minimum amount of data still to be flushed 0 if fully flushed or an error code note : needs to be init using any ZSTD_initCStream*() variant"],["ZSTDMT_createCCtx_advanced",""],["ZSTDMT_freeCCtx",""],["ZSTDMT_getFrameProgression","ZSTDMT_getFrameProgression(): tells how much data has been consumed (input) and produced (output) for current frame. able to count progression inside worker threads."],["ZSTDMT_initCStream_internal","ZSTDMT_initCStream_internal() : Private use only. Init streaming operation. expects params to be valid. must receive dict, or cdict, or none, but not both. @return : 0, or an error code"],["ZSTDMT_nextInputSizeHint",""],["ZSTDMT_sizeof_CCtx",""],["ZSTDMT_toFlushNow","ZSTDMT_toFlushNow() Tell how many bytes are ready to be flushed immediately. Probe the oldest active job (not yet entirely flushed) and check its output buffer. If return 0, it means there is no active job, or, it means oldest job is still active, but everything produced has been flushed so far, therefore flushing is limited by speed of oldest job."],["ZSTDMT_updateCParams_whileCompressing","ZSTDMT_updateCParams_whileCompressing() : Updates only a selected set of compression parameters, to remain compatible with current frame. New parameters will be applied to next compression job."],["ZSTD_CCtxParams_getParameter","ZSTD_CCtxParams_getParameter() : Similar to ZSTD_CCtx_getParameter. Get the requested value of one compression parameter, selected by enum ZSTD_cParameter. @result : 0, or an error code (which can be tested with ZSTD_isError())."],["ZSTD_CCtxParams_init","ZSTD_CCtxParams_init() : Initializes the compression parameters of cctxParams according to compression level. All other parameters are reset to their default values."],["ZSTD_CCtxParams_init_advanced","ZSTD_CCtxParams_init_advanced() : Initializes the compression and frame parameters of cctxParams according to params. All other parameters are reset to their default values."],["ZSTD_CCtxParams_reset","ZSTD_CCtxParams_reset() : Reset params to default values."],["ZSTD_CCtxParams_setParameter","ZSTD_CCtxParams_setParameter() : Similar to ZSTD_CCtx_setParameter. Set one compression parameter, selected by enum ZSTD_cParameter. Parameters must be applied to a ZSTD_CCtx using ZSTD_CCtx_setParametersUsingCCtxParams(). @result : a code representing success or failure (which can be tested with ZSTD_isError())."],["ZSTD_CCtx_getParameter","ZSTD_CCtx_getParameter() : Get the requested compression parameter value, selected by enum ZSTD_cParameter, and store it into int* value. @return : 0, or an error code (which can be tested with ZSTD_isError())."],["ZSTD_CCtx_loadDictionary","ZSTD_CCtx_loadDictionary() : Create an internal CDict from `dict` buffer. Decompression will have to use same dictionary. @result : 0, or an error code (which can be tested with ZSTD_isError()). Special: Loading a NULL (or 0-size) dictionary invalidates previous dictionary, meaning “return to no-dictionary mode”. Note 1 : Dictionary is sticky, it will be used for all future compressed frames. To return to “no-dictionary” situation, load a NULL dictionary (or reset parameters). Note 2 : Loading a dictionary involves building tables. It’s also a CPU consuming operation, with non-negligible impact on latency. Tables are dependent on compression parameters, and for this reason, compression parameters can no longer be changed after loading a dictionary. Note 3 :`dict` content will be copied internally. Use experimental ZSTD_CCtx_loadDictionary_byReference() to reference content instead. In such a case, dictionary buffer must outlive its users. Note 4 : Use ZSTD_CCtx_loadDictionary_advanced() to precisely select how dictionary content must be interpreted."],["ZSTD_CCtx_loadDictionary_advanced","ZSTD_CCtx_loadDictionary_advanced() : Same as ZSTD_CCtx_loadDictionary(), but gives finer control over how to load the dictionary (by copy ? by reference ?) and how to interpret it (automatic ? force raw mode ? full mode only ?)"],["ZSTD_CCtx_loadDictionary_byReference","ZSTD_CCtx_loadDictionary_byReference() : Same as ZSTD_CCtx_loadDictionary(), but dictionary content is referenced, instead of being copied into CCtx. It saves some memory, but also requires that `dict` outlives its usage within `cctx`"],["ZSTD_CCtx_refCDict","ZSTD_CCtx_refCDict() : Reference a prepared dictionary, to be used for all next compressed frames. Note that compression parameters are enforced from within CDict, and supersede any compression parameter previously set within CCtx. The parameters ignored are labled as “superseded-by-cdict” in the ZSTD_cParameter enum docs. The ignored parameters will be used again if the CCtx is returned to no-dictionary mode. The dictionary will remain valid for future compressed frames using same CCtx. @result : 0, or an error code (which can be tested with ZSTD_isError()). Special : Referencing a NULL CDict means “return to no-dictionary mode”. Note 1 : Currently, only one dictionary can be managed. Referencing a new dictionary effectively “discards” any previous one. Note 2 : CDict is just referenced, its lifetime must outlive its usage within CCtx."],["ZSTD_CCtx_refPrefix","ZSTD_CCtx_refPrefix() : Reference a prefix (single-usage dictionary) for next compressed frame. A prefix is only used once. Tables are discarded at end of frame (ZSTD_e_end). Decompression will need same prefix to properly regenerate data. Compressing with a prefix is similar in outcome as performing a diff and compressing it, but performs much faster, especially during decompression (compression speed is tunable with compression level). @result : 0, or an error code (which can be tested with ZSTD_isError()). Special: Adding any prefix (including NULL) invalidates any previous prefix or dictionary Note 1 : Prefix buffer is referenced. It must outlive compression. Its content must remain unmodified during compression. Note 2 : If the intention is to diff some large src data blob with some prior version of itself, ensure that the window size is large enough to contain the entire source. See ZSTD_c_windowLog. Note 3 : Referencing a prefix involves building tables, which are dependent on compression parameters. It’s a CPU consuming operation, with non-negligible impact on latency. If there is a need to use the same prefix multiple times, consider loadDictionary instead. Note 4 : By default, the prefix is interpreted as raw content (ZSTD_dct_rawContent). Use experimental ZSTD_CCtx_refPrefix_advanced() to alter dictionary interpretation."],["ZSTD_CCtx_refPrefix_advanced","ZSTD_CCtx_refPrefix_advanced() : Same as ZSTD_CCtx_refPrefix(), but gives finer control over how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"],["ZSTD_CCtx_refThreadPool",""],["ZSTD_CCtx_reset","ZSTD_CCtx_reset() : There are 2 different things that can be reset, independently or jointly :"],["ZSTD_CCtx_setParameter","ZSTD_CCtx_setParameter() : Set one compression parameter, selected by enum ZSTD_cParameter. All parameters have valid bounds. Bounds can be queried using ZSTD_cParam_getBounds(). Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter). Setting a parameter is generally only possible during frame initialization (before starting compression). Exception : when using multi-threading mode (nbWorkers >= 1), the following parameters can be updated during compression (within same frame): => compressionLevel, hashLog, chainLog, searchLog, minMatch, targetLength and strategy. new parameters will be active for next job only (after a flush()). @return : an error code (which can be tested using ZSTD_isError())."],["ZSTD_CCtx_setParametersUsingCCtxParams","ZSTD_CCtx_setParametersUsingCCtxParams() : Apply a set of ZSTD_CCtx_params to the compression context. This can be done even after compression is started, if nbWorkers==0, this will have no impact until a new compression is started. if nbWorkers>=1, new parameters will be picked up at next job, with a few restrictions (windowLog, pledgedSrcSize, nbWorkers, jobSize, and overlapLog are not updated)."],["ZSTD_CCtx_setPledgedSrcSize","ZSTD_CCtx_setPledgedSrcSize() : Total input data size to be compressed as a single frame. Value will be written in frame header, unless if explicitly forbidden using ZSTD_c_contentSizeFlag. This value will also be controlled at end of frame, and trigger an error if not respected. @result : 0, or an error code (which can be tested with ZSTD_isError()). Note 1 : pledgedSrcSize==0 actually means zero, aka an empty frame. In order to mean “unknown content size”, pass constant ZSTD_CONTENTSIZE_UNKNOWN. ZSTD_CONTENTSIZE_UNKNOWN is default value for any new frame. Note 2 : pledgedSrcSize is only valid once, for the next frame. It’s discarded at the end of the frame, and replaced by ZSTD_CONTENTSIZE_UNKNOWN. Note 3 : Whenever all input data is provided and consumed in a single round, for example with ZSTD_compress2(), or invoking immediately ZSTD_compressStream2(,,,ZSTD_e_end), this value is automatically overridden by srcSize instead."],["ZSTD_CStreamInSize",""],["ZSTD_CStreamOutSize",""],["ZSTD_DCtx_getParameter","ZSTD_DCtx_getParameter() : Get the requested decompression parameter value, selected by enum ZSTD_dParameter, and store it into int* value. @return : 0, or an error code (which can be tested with ZSTD_isError())."],["ZSTD_DCtx_loadDictionary","ZSTD_DCtx_loadDictionary() : Create an internal DDict from dict buffer, to be used to decompress next frames. The dictionary remains valid for all future frames, until explicitly invalidated. @result : 0, or an error code (which can be tested with ZSTD_isError()). Special : Adding a NULL (or 0-size) dictionary invalidates any previous dictionary, meaning “return to no-dictionary mode”. Note 1 : Loading a dictionary involves building tables, which has a non-negligible impact on CPU usage and latency. It’s recommended to “load once, use many times”, to amortize the cost Note 2 :`dict` content will be copied internally, so `dict` can be released after loading. Use ZSTD_DCtx_loadDictionary_byReference() to reference dictionary content instead. Note 3 : Use ZSTD_DCtx_loadDictionary_advanced() to take control of how dictionary content is loaded and interpreted."],["ZSTD_DCtx_loadDictionary_advanced","ZSTD_DCtx_loadDictionary_advanced() : Same as ZSTD_DCtx_loadDictionary(), but gives direct control over how to load the dictionary (by copy ? by reference ?) and how to interpret it (automatic ? force raw mode ? full mode only ?)."],["ZSTD_DCtx_loadDictionary_byReference","ZSTD_DCtx_loadDictionary_byReference() : Same as ZSTD_DCtx_loadDictionary(), but references `dict` content instead of copying it into `dctx`. This saves memory if `dict` remains around., However, it’s imperative that `dict` remains accessible (and unmodified) while being used, so it must outlive decompression."],["ZSTD_DCtx_refDDict","ZSTD_DCtx_refDDict() : Reference a prepared dictionary, to be used to decompress next frames. The dictionary remains active for decompression of future frames using same DCtx. @result : 0, or an error code (which can be tested with ZSTD_isError()). Note 1 : Currently, only one dictionary can be managed. Referencing a new dictionary effectively “discards” any previous one. Special: referencing a NULL DDict means “return to no-dictionary mode”. Note 2 : DDict is just referenced, its lifetime must outlive its usage from DCtx."],["ZSTD_DCtx_refPrefix","ZSTD_DCtx_refPrefix() : Reference a prefix (single-usage dictionary) to decompress next frame. This is the reverse operation of ZSTD_CCtx_refPrefix(), and must use the same prefix as the one used during compression. Prefix is only used once. Reference is discarded at end of frame. End of frame is reached when ZSTD_decompressStream() returns 0. @result : 0, or an error code (which can be tested with ZSTD_isError()). Note 1 : Adding any prefix (including NULL) invalidates any previously set prefix or dictionary Note 2 : Prefix buffer is referenced. It must outlive decompression. Prefix buffer must remain unmodified up to the end of frame, reached when ZSTD_decompressStream() returns 0. Note 3 : By default, the prefix is treated as raw content (ZSTD_dct_rawContent). Use ZSTD_CCtx_refPrefix_advanced() to alter dictMode (Experimental section) Note 4 : Referencing a raw content prefix has almost no cpu nor memory cost. A full dictionary is more costly, as it requires building tables."],["ZSTD_DCtx_refPrefix_advanced","ZSTD_DCtx_refPrefix_advanced() : Same as ZSTD_DCtx_refPrefix(), but gives finer control over how to interpret prefix content (automatic ? force raw mode (default) ? full mode only ?)"],["ZSTD_DCtx_reset","ZSTD_DCtx_reset() : Return a DCtx to clean state. Session and parameters can be reset jointly or separately. Parameters can only be reset when no active frame is being decompressed. @return : 0, or an error code, which can be tested with ZSTD_isError()"],["ZSTD_DCtx_setFormat","ZSTD_DCtx_setFormat() : Instruct the decoder context about what kind of data to decode next. This instruction is mandatory to decode data without a fully-formed header, such ZSTD_f_zstd1_magicless for example. @return : 0, or an error code (which can be tested using ZSTD_isError())."],["ZSTD_DCtx_setMaxWindowSize","ZSTD_DCtx_setMaxWindowSize() : Refuses allocating internal buffers for frames requiring a window size larger than provided limit. This protects a decoder context from reserving too much memory for itself (potential attack scenario). This parameter is only useful in streaming mode, since no internal buffer is allocated in single-pass mode. By default, a decompression context accepts all window sizes <= (1 << ZSTD_WINDOWLOG_LIMIT_DEFAULT) @return : 0, or an error code (which can be tested using ZSTD_isError())."],["ZSTD_DCtx_setParameter","ZSTD_DCtx_setParameter() : Set one compression parameter, selected by enum ZSTD_dParameter. All parameters have valid bounds. Bounds can be queried using ZSTD_dParam_getBounds(). Providing a value beyond bound will either clamp it, or trigger an error (depending on parameter). Setting a parameter is only possible during frame initialization (before starting decompression). @return : 0, or an error code (which can be tested using ZSTD_isError())."],["ZSTD_DStreamInSize",""],["ZSTD_DStreamOutSize",""],["ZSTD_adjustCParams","ZSTD_adjustCParams() : optimize params for a given `srcSize` and `dictSize`. `srcSize` can be unknown, in which case use ZSTD_CONTENTSIZE_UNKNOWN. `dictSize` must be `0` when there is no dictionary. cPar can be invalid : all parameters will be clamped within valid range in the @return struct. This function never fails (wide contract)"],["ZSTD_cParam_getBounds","ZSTD_cParam_getBounds() : All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped. @return : a structure, ZSTD_bounds, which contains - an error status field, which must be tested using ZSTD_isError() - lower and upper bounds, both inclusive"],["ZSTD_checkCParams","ZSTD_checkCParams() : Ensure param values remain within authorized range. @return 0 on success, or an error code (can be checked with ZSTD_isError())"],["ZSTD_compress","Simple API Compresses `src` content as a single zstd compressed frame into already allocated `dst`. Hint : compression runs faster if `dstCapacity` >=  `ZSTD_compressBound(srcSize)`. @return : compressed size written into `dst` (<= `dstCapacity), or an error code if it fails (which can be tested using ZSTD_isError())."],["ZSTD_compress2","ZSTD_compress2() : Behave the same as ZSTD_compressCCtx(), but compression parameters are set using the advanced API. ZSTD_compress2() always starts a new frame. Should cctx hold data from a previously unfinished frame, everything about it is forgotten."],["ZSTD_compressBegin","Buffer-less streaming compression (synchronous mode)"],["ZSTD_compressBegin_advanced",""],["ZSTD_compressBegin_usingCDict",""],["ZSTD_compressBegin_usingCDict_advanced",""],["ZSTD_compressBegin_usingDict",""],["ZSTD_compressBlock",""],["ZSTD_compressBound",""],["ZSTD_compressCCtx","ZSTD_compressCCtx() : Same as ZSTD_compress(), using an explicit ZSTD_CCtx. Important : in order to behave similarly to `ZSTD_compress()`, this function compresses at requested compression level, ignoring any other parameter . If any advanced parameter was set using the advanced API, they will all be reset. Only `compressionLevel` remains."],["ZSTD_compressContinue",""],["ZSTD_compressEnd",""],["ZSTD_compressSequences","ZSTD_compressSequences() : Compress an array of ZSTD_Sequence, generated from the original source buffer, into dst. If a dictionary is included, then the cctx should reference the dict. (see: ZSTD_CCtx_refCDict(), ZSTD_CCtx_loadDictionary(), etc.) The entire source is compressed into a single frame."],["ZSTD_compressStream","Alternative for ZSTD_compressStream2(zcs, output, input, ZSTD_e_continue). NOTE: The return value is different. ZSTD_compressStream() returns a hint for the next read size (if non-zero and not an error). ZSTD_compressStream2() returns the minimum nb of bytes left to flush (if non-zero and not an error)."],["ZSTD_compressStream2","ZSTD_compressStream2() : Behaves about the same as ZSTD_compressStream, with additional control on end directive."],["ZSTD_compressStream2_simpleArgs","ZSTD_compressStream2_simpleArgs() : Same as ZSTD_compressStream2(), but using only integral types as arguments. This variant might be helpful for binders from dynamic languages which have troubles handling structures containing memory pointers."],["ZSTD_compress_advanced","ZSTD_compress_advanced() : Note : this function is now DEPRECATED. It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_setParameter() and other parameter setters. This prototype will be marked as deprecated and generate compilation warning on reaching v1.5.x"],["ZSTD_compress_usingCDict","ZSTD_compress_usingCDict() : Compression using a digested Dictionary. Recommended when same dictionary is used multiple times. Note : compression level is decided at dictionary creation time, and frame parameters are hardcoded (dictID=yes, contentSize=yes, checksum=no)"],["ZSTD_compress_usingCDict_advanced","ZSTD_compress_usingCDict_advanced() : Note : this function is now REDUNDANT. It can be replaced by ZSTD_compress2(), in combination with ZSTD_CCtx_loadDictionary() and other parameter setters. This prototype will be marked as deprecated and generate compilation warning in some future version"],["ZSTD_compress_usingDict","Simple dictionary API Compression at an explicit compression level using a Dictionary. A dictionary can be any arbitrary data segment (also called a prefix), or a buffer with specified information (see dictBuilder/zdict.h). Note : This function loads the dictionary, resulting in significant startup delay. It’s intended for a dictionary used only once. Note 2 : When `dict == NULL || dictSize < 8` no dictionary is used."],["ZSTD_copyCCtx",""],["ZSTD_copyDCtx",""],["ZSTD_createCCtx",""],["ZSTD_createCCtxParams","ZSTD_CCtx_params : Quick howto :"],["ZSTD_createCCtx_advanced",""],["ZSTD_createCDict","ZSTD_createCDict() : When compressing multiple messages or blocks using the same dictionary, it’s recommended to digest the dictionary only once, since it’s a costly operation. ZSTD_createCDict() will create a state from digesting a dictionary. The resulting state can be used for future compression operations with very limited startup cost. ZSTD_CDict can be created once and shared by multiple threads concurrently, since its usage is read-only. @dictBuffer can be released after ZSTD_CDict creation, because its content is copied within CDict. Note 1 : Consider experimental function `ZSTD_createCDict_byReference()` if you prefer to not duplicate @dictBuffer content. Note 2 : A ZSTD_CDict can be created from an empty @dictBuffer, in which case the only thing that it transports is the @compressionLevel. This can be useful in a pipeline featuring ZSTD_compress_usingCDict() exclusively, expecting a ZSTD_CDict parameter with any data, including those without a known dictionary."],["ZSTD_createCDict_advanced",""],["ZSTD_createCDict_advanced2",""],["ZSTD_createCDict_byReference","ZSTD_createCDict_byReference() : Create a digested dictionary for compression Dictionary content is just referenced, not duplicated. As a consequence, `dictBuffer` must outlive CDict, and its content must remain unmodified throughout the lifetime of CDict. note: equivalent to ZSTD_createCDict_advanced(), with dictLoadMethod==ZSTD_dlm_byRef"],["ZSTD_createCStream",""],["ZSTD_createCStream_advanced",""],["ZSTD_createDCtx",""],["ZSTD_createDCtx_advanced",""],["ZSTD_createDDict","ZSTD_createDDict() : Create a digested dictionary, ready to start decompression operation without startup delay. dictBuffer can be released after DDict creation, as its content is copied inside DDict."],["ZSTD_createDDict_advanced",""],["ZSTD_createDDict_byReference","ZSTD_createDDict_byReference() : Create a digested dictionary, ready to start decompression operation without startup delay. Dictionary content is referenced, and therefore stays in dictBuffer. It is important that dictBuffer outlives DDict, it must remain read accessible throughout the lifetime of DDict"],["ZSTD_createDStream",""],["ZSTD_createDStream_advanced",""],["ZSTD_createThreadPool",""],["ZSTD_dParam_getBounds","ZSTD_dParam_getBounds() : All parameters must belong to an interval with lower and upper bounds, otherwise they will either trigger an error or be automatically clamped. @return : a structure, ZSTD_bounds, which contains - an error status field, which must be tested using ZSTD_isError() - both lower and upper bounds, inclusive"],["ZSTD_decodingBufferSize_min",""],["ZSTD_decompress","ZSTD_decompress() : `compressedSize` : must be the exact size of some number of compressed and/or skippable frames. `dstCapacity` is an upper bound of originalSize to regenerate. If user cannot imply a maximum upper bound, it’s better to use streaming mode to decompress data. @return : the number of bytes decompressed into `dst` (<= `dstCapacity`), or an errorCode if it fails (which can be tested using ZSTD_isError())."],["ZSTD_decompressBegin",""],["ZSTD_decompressBegin_usingDDict",""],["ZSTD_decompressBegin_usingDict",""],["ZSTD_decompressBlock",""],["ZSTD_decompressBound","ZSTD_decompressBound() : `src` should point to the start of a series of ZSTD encoded and/or skippable frames `srcSize` must be the exact size of this series (i.e. there should be a frame boundary at `src + srcSize`) @return : - upper-bound for the decompressed size of all data in all successive frames - if an error occured: ZSTD_CONTENTSIZE_ERROR"],["ZSTD_decompressContinue",""],["ZSTD_decompressDCtx","ZSTD_decompressDCtx() : Same as ZSTD_decompress(), requires an allocated ZSTD_DCtx. Compatible with sticky parameters."],["ZSTD_decompressStream",""],["ZSTD_decompressStream_simpleArgs","ZSTD_decompressStream_simpleArgs() : Same as ZSTD_decompressStream(), but using only integral types as arguments. This can be helpful for binders from dynamic languages which have troubles handling structures containing memory pointers."],["ZSTD_decompress_usingDDict","ZSTD_decompress_usingDDict() : Decompression using a digested Dictionary. Recommended when same dictionary is used multiple times."],["ZSTD_decompress_usingDict","ZSTD_decompress_usingDict() : Decompression using a known Dictionary. Dictionary must be identical to the one used during compression. Note : This function loads the dictionary, resulting in significant startup delay. It’s intended for a dictionary used only once. Note : When `dict == NULL || dictSize < 8` no dictionary is used."],["ZSTD_endStream","Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_end)."],["ZSTD_estimateCCtxSize","ZSTD_estimate*() : These functions make it possible to estimate memory usage of a future {D,C}Ctx, before its creation."],["ZSTD_estimateCCtxSize_usingCCtxParams",""],["ZSTD_estimateCCtxSize_usingCParams",""],["ZSTD_estimateCDictSize","ZSTD_estimate?DictSize() : ZSTD_estimateCDictSize() will bet that src size is relatively “small”, and content is copied, like ZSTD_createCDict(). ZSTD_estimateCDictSize_advanced() makes it possible to control compression parameters precisely, like ZSTD_createCDict_advanced(). Note : dictionaries created by reference (`ZSTD_dlm_byRef`) are logically smaller."],["ZSTD_estimateCDictSize_advanced",""],["ZSTD_estimateCStreamSize","ZSTD_estimateCStreamSize() : ZSTD_estimateCStreamSize() will provide a budget large enough for any compression level up to selected one. It will also consider src size to be arbitrarily “large”, which is worst case. If srcSize is known to always be small, ZSTD_estimateCStreamSize_usingCParams() can provide a tighter estimation. ZSTD_estimateCStreamSize_usingCParams() can be used in tandem with ZSTD_getCParams() to create cParams from compressionLevel. ZSTD_estimateCStreamSize_usingCCtxParams() can be used in tandem with ZSTD_CCtxParams_setParameter(). Only single-threaded compression is supported. This function will return an error code if ZSTD_c_nbWorkers is >= 1. Note : CStream size estimation is only correct for single-threaded compression. ZSTD_DStream memory budget depends on window Size. This information can be passed manually, using ZSTD_estimateDStreamSize, or deducted from a valid frame Header, using ZSTD_estimateDStreamSize_fromFrame(); Note : if streaming is init with function ZSTD_init?Stream_usingDict(), an internal ?Dict will be created, which additional size is not estimated here. In this case, get total size by adding ZSTD_estimate?DictSize"],["ZSTD_estimateCStreamSize_usingCCtxParams",""],["ZSTD_estimateCStreamSize_usingCParams",""],["ZSTD_estimateDCtxSize",""],["ZSTD_estimateDDictSize",""],["ZSTD_estimateDStreamSize",""],["ZSTD_estimateDStreamSize_fromFrame",""],["ZSTD_findDecompressedSize","ZSTD_findDecompressedSize() : `src` should point to the start of a series of ZSTD encoded and/or skippable frames `srcSize` must be the exact size of this series (i.e. there should be a frame boundary at `src + srcSize`) @return : - decompressed size of all data in all successive frames - if the decompressed size cannot be determined: ZSTD_CONTENTSIZE_UNKNOWN - if an error occurred: ZSTD_CONTENTSIZE_ERROR"],["ZSTD_findFrameCompressedSize","ZSTD_findFrameCompressedSize() : `src` should point to the start of a ZSTD frame or skippable frame. `srcSize` must be >= first frame size @return : the compressed size of the first frame starting at `src`, suitable to pass as `srcSize` to `ZSTD_decompress` or similar, or an error code if input is invalid"],["ZSTD_flushStream","Equivalent to ZSTD_compressStream2(zcs, output, &emptyInput, ZSTD_e_flush)."],["ZSTD_frameHeaderSize","ZSTD_frameHeaderSize() : srcSize must be >= ZSTD_FRAMEHEADERSIZE_PREFIX. @return : size of the Frame Header, or an error code (if srcSize is too small)"],["ZSTD_freeCCtx",""],["ZSTD_freeCCtxParams",""],["ZSTD_freeCDict","ZSTD_freeCDict() : Function frees memory allocated by ZSTD_createCDict()."],["ZSTD_freeCStream",""],["ZSTD_freeDCtx",""],["ZSTD_freeDDict","ZSTD_freeDDict() : Function frees memory allocated with ZSTD_createDDict()"],["ZSTD_freeDStream",""],["ZSTD_freeThreadPool",""],["ZSTD_generateSequences","ZSTD_generateSequences() : Generate sequences using ZSTD_compress2, given a source buffer."],["ZSTD_getBlockSize","Block functions produce and decode raw zstd blocks, without frame metadata. Frame metadata cost is typically ~12 bytes, which can be non-negligible for very small blocks (< 100 bytes). But users will have to take in charge needed metadata to regenerate data, such as compressed and content sizes."],["ZSTD_getCParams","ZSTD_getCParams() : @return ZSTD_compressionParameters structure for a selected compression level and estimated srcSize. `estimatedSrcSize` value is optional, select 0 if not known"],["ZSTD_getDecompressedSize","ZSTD_getDecompressedSize() : NOTE: This function is now obsolete, in favor of ZSTD_getFrameContentSize(). Both functions work the same way, but ZSTD_getDecompressedSize() blends “empty”, “unknown” and “error” results to the same return value (0), while ZSTD_getFrameContentSize() gives them separate return values. @return : decompressed size of `src` frame content if known and not empty, 0 otherwise."],["ZSTD_getDictID_fromCDict","ZSTD_getDictID_fromCDict() : Provides the dictID of the dictionary loaded into `cdict`. If @return == 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries."],["ZSTD_getDictID_fromDDict","ZSTD_getDictID_fromDDict() : Provides the dictID of the dictionary loaded into `ddict`. If @return == 0, the dictionary is not conformant to Zstandard specification, or empty. Non-conformant dictionaries can still be loaded, but as content-only dictionaries."],["ZSTD_getDictID_fromDict","ZSTD_getDictID_fromDict() : Provides the dictID stored within dictionary. if @return == 0, the dictionary is not conformant with Zstandard specification. It can still be loaded, but as a content-only dictionary."],["ZSTD_getDictID_fromFrame","ZSTD_getDictID_fromFrame() : Provides the dictID required to decompressed the frame stored within `src`. If @return == 0, the dictID could not be decoded. This could for one of the following reasons :"],["ZSTD_getErrorName",""],["ZSTD_getFrameContentSize",""],["ZSTD_getFrameHeader","ZSTD_getFrameHeader() : decode Frame Header, or requires larger `srcSize`. @return : 0, `zfhPtr` is correctly filled, >0, `srcSize` is too small, value is wanted `srcSize` amount, or an error code, which can be tested using ZSTD_isError()"],["ZSTD_getFrameHeader_advanced","ZSTD_getFrameHeader_advanced() : same as ZSTD_getFrameHeader(), with added capability to select a format (like ZSTD_f_zstd1_magicless)"],["ZSTD_getFrameProgression",""],["ZSTD_getParams","ZSTD_getParams() : same as ZSTD_getCParams(), but @return a full `ZSTD_parameters` object instead of sub-component `ZSTD_compressionParameters`. All fields of `ZSTD_frameParameters` are set to default : contentSize=1, checksum=0, noDictID=0"],["ZSTD_initCStream","Equivalent to:"],["ZSTD_initCStream_advanced","ZSTD_initCStream_advanced() : This function is deprecated, and is approximately equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); // Pseudocode: Set each zstd parameter and leave the rest as-is. for ((param, value) : params) { ZSTD_CCtx_setParameter(zcs, param, value); } ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize); ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"],["ZSTD_initCStream_srcSize","ZSTD_initCStream_srcSize() : This function is deprecated, and equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_refCDict(zcs, NULL); // clear the dictionary (if any) ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"],["ZSTD_initCStream_usingCDict","ZSTD_initCStream_usingCDict() : This function is deprecated, and equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_refCDict(zcs, cdict);"],["ZSTD_initCStream_usingCDict_advanced","ZSTD_initCStream_usingCDict_advanced() : This function is DEPRECATED, and is approximately equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); // Pseudocode: Set each zstd frame parameter and leave the rest as-is. for ((fParam, value) : fParams) { ZSTD_CCtx_setParameter(zcs, fParam, value); } ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize); ZSTD_CCtx_refCDict(zcs, cdict);"],["ZSTD_initCStream_usingDict","ZSTD_initCStream_usingDict() : This function is deprecated, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setParameter(zcs, ZSTD_c_compressionLevel, compressionLevel); ZSTD_CCtx_loadDictionary(zcs, dict, dictSize);"],["ZSTD_initDStream",""],["ZSTD_initDStream_usingDDict","This function is deprecated, and is equivalent to:"],["ZSTD_initDStream_usingDict","This function is deprecated, and is equivalent to:"],["ZSTD_initStaticCCtx","ZSTD_initStatic*() : Initialize an object using a pre-allocated fixed-size buffer. workspace: The memory area to emplace the object into. Provided pointer must be 8-bytes aligned. Buffer must outlive object. workspaceSize: Use ZSTD_estimate*Size() to determine how large workspace must be to support target scenario. @return : pointer to object (same address as workspace, just different type), or NULL if error (size too small, incorrect alignment, etc.) Note : zstd will never resize nor malloc() when using a static buffer. If the object requires more memory than available, zstd will just error out (typically ZSTD_error_memory_allocation). Note 2 : there is no corresponding “free” function. Since workspace is allocated externally, it must be freed externally too. Note 3 : cParams : use ZSTD_getCParams() to convert a compression level into its associated cParams. Limitation 1 : currently not compatible with internal dictionary creation, triggered by ZSTD_CCtx_loadDictionary(), ZSTD_initCStream_usingDict() or ZSTD_initDStream_usingDict(). Limitation 2 : static cctx currently not compatible with multi-threading. Limitation 3 : static dctx is incompatible with legacy support."],["ZSTD_initStaticCDict",""],["ZSTD_initStaticCStream",""],["ZSTD_initStaticDCtx",""],["ZSTD_initStaticDDict",""],["ZSTD_initStaticDStream",""],["ZSTD_insertBlock",""],["ZSTD_isError",""],["ZSTD_isFrame","ZSTD_isFrame() : Tells if the content of `buffer` starts with a valid Frame Identifier. Note : Frame Identifier is 4 bytes. If `size < 4`, @return will always be 0. Note 2 : Legacy Frame Identifiers are considered valid only if Legacy Support is enabled. Note 3 : Skippable Frame Identifiers are considered valid."],["ZSTD_maxCLevel",""],["ZSTD_mergeBlockDelimiters","ZSTD_mergeBlockDelimiters() : Given an array of ZSTD_Sequence, remove all sequences that represent block delimiters/last literals by merging them into into the literals of the next sequence."],["ZSTD_minCLevel",""],["ZSTD_nextInputType",""],["ZSTD_nextSrcSizeToDecompress",""],["ZSTD_resetCStream","ZSTD_resetCStream() : This function is deprecated, and is equivalent to: ZSTD_CCtx_reset(zcs, ZSTD_reset_session_only); ZSTD_CCtx_setPledgedSrcSize(zcs, pledgedSrcSize);"],["ZSTD_resetDStream","This function is deprecated, and is equivalent to:"],["ZSTD_sizeof_CCtx","ZSTD_sizeof_*() : These functions give the current memory usage of selected object. Note that object memory usage can evolve (increase or decrease) over time."],["ZSTD_sizeof_CDict",""],["ZSTD_sizeof_CStream",""],["ZSTD_sizeof_DCtx",""],["ZSTD_sizeof_DDict",""],["ZSTD_sizeof_DStream",""],["ZSTD_toFlushNow","ZSTD_toFlushNow() : Tell how many bytes are ready to be flushed immediately. Useful for multithreading scenarios (nbWorkers >= 1). Probe the oldest active job, defined as oldest job not yet entirely flushed, and check its output buffer. @return : amount of data stored in oldest job and ready to be flushed immediately. if @return == 0, it means either : + there is no active job (could be checked with ZSTD_frameProgression()), or + oldest job is still actively compressing data, but everything it has produced has also been flushed so far, therefore flush speed is limited by production speed of oldest job irrespective of the speed of concurrent (and newer) jobs."],["ZSTD_versionNumber","ZSTD_versionNumber() : Return runtime library version, the value is (MAJOR100100 + MINOR*100 + RELEASE)."],["ZSTD_versionString","ZSTD_versionString() : Return runtime library version, like “1.4.5”. Requires v1.3.0+."],["__stpcpy",""],["__stpncpy",""],["__strtok_r",""],["bcmp",""],["bcopy",""],["bzero",""],["explicit_bzero",""],["ffs",""],["ffsl",""],["ffsll",""],["index",""],["memccpy",""],["memchr",""],["memcmp",""],["memcpy",""],["memmove",""],["memset",""],["rindex",""],["stpcpy",""],["stpncpy",""],["strcasecmp",""],["strcasecmp_l",""],["strcat",""],["strchr",""],["strcmp",""],["strcoll",""],["strcoll_l",""],["strcpy",""],["strcspn",""],["strdup",""],["strerror",""],["strerror_l",""],["strerror_r",""],["strlen",""],["strncasecmp",""],["strncasecmp_l",""],["strncat",""],["strncmp",""],["strncpy",""],["strndup",""],["strnlen",""],["strpbrk",""],["strrchr",""],["strsep",""],["strsignal",""],["strspn",""],["strstr",""],["strtok",""],["strtok_r",""],["strxfrm",""],["strxfrm_l",""]],"static":[["ZSTD_defaultCMem",""]],"struct":[["POOL_ctx_s",""],["ZDICT_cover_params_t","ZDICT_cover_params_t: k and d are the only required parameters. For others, value 0 means default."],["ZDICT_fastCover_params_t",""],["ZDICT_legacy_params_t",""],["ZDICT_params_t",""],["ZSTDMT_CCtx_s",""],["ZSTD_CCtx_params_s",""],["ZSTD_CCtx_s",""],["ZSTD_CDict_s",""],["ZSTD_DCtx_s",""],["ZSTD_DDict_s",""],["ZSTD_Sequence",""],["ZSTD_bounds",""],["ZSTD_compressionParameters",""],["ZSTD_customMem",""],["ZSTD_frameHeader",""],["ZSTD_frameParameters",""],["ZSTD_frameProgression",""],["ZSTD_inBuffer_s","Streaming"],["ZSTD_outBuffer_s",""],["ZSTD_parameters",""],["__locale_data",""],["__locale_struct",""]],"type":[["ZSTDMT_CCtx",""],["ZSTD_CCtx","Explicit context"],["ZSTD_CCtx_params",""],["ZSTD_CDict","Bulk processing dictionary API"],["ZSTD_CStream",""],["ZSTD_DCtx",""],["ZSTD_DDict",""],["ZSTD_DStream",""],["ZSTD_allocFunction","Custom memory allocation : These prototypes make it possible to pass your own allocation/free functions. ZSTD_customMem is provided at creation time, using ZSTD_create*_advanced() variants listed below. All allocation/free operations will be completed using these custom variants instead of regular <stdlib.h> ones."],["ZSTD_freeFunction",""],["ZSTD_inBuffer","Streaming"],["ZSTD_outBuffer",""],["ZSTD_threadPool",""],["__locale_t",""],["locale_t",""],["wchar_t",""]]});